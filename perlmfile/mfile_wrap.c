/*
 * FILE : mfile_wrap.c
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 5)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* Implementation : PERL 5 */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#undef free
#undef malloc
#include <string.h>
#ifdef __cplusplus
}
#endif
/* Definitions for compiling Perl extensions on a variety of machines */

#if defined(WIN32) || defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a,b) __declspec(dllexport) a b
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a,b) a _export b
#	else
#	    define SWIGEXPORT(a,b) a b
#	endif
#   endif
#else
#   define SWIGEXPORT(a,b) a b
#endif

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerl *pPerl = (CPerl *) this;
#define MAGIC_CAST   (int (CPerl::*)(SV *, MAGIC *))
#define SWIGCLASS_STATIC 
#else
#define MAGIC_PPERL
#define MAGIC_CAST
#define SWIGCLASS_STATIC static
#endif


/*****************************************************************************
 * $Header: /home/beazley/SWIG/SWIG1.1b3/swig_lib/perl5/RCS/perl5ptr.swg,v 1.1 1996/12/26 22:17:29 beazley Exp beazley $
 *
 * perl5ptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is only used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer.
 *
 * char * SWIG_GetPtr(SV *obj, void **ptr, char *type)
 *
 *      Gets a pointer value from a Perl5 scalar value.  If there is a 
 *      type-mismatch, returns a character string to the received type.  
 *      On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *
 * $Log: perl5ptr.swg,v $
 * Revision 1.1  1996/12/26 22:17:29  beazley
 * Initial revision
 *
 *****************************************************************************/

#include <stdlib.h>

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

/* These are internal variables.   Should be static */

typedef struct SwigPtrType {
  char               *name;
  int                 len;
  void               *(*cast)(void *);
  struct SwigPtrType *next;
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */
static int SwigStart[256];             /* Table containing starting positions    */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

#ifndef PERL_OBJECT
SWIGSTATIC 
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {
#else
SWIGSTATIC
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl, a,b,c)
void _SWIG_RegisterMapping(CPerl *pPerl, char *origtype, char *newtype, void *(*cast)(void *)) {
#endif

  int i;
  SwigPtrType *t = 0, *t1;

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc(SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }
  while (t->next) {
    if (strcmp(t->name,newtype) == 0) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;
  t->next = t1;
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC 
void SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex   SWIG_MakePtr 

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGSTATIC 
char *SWIG_GetPtr(SV *sv, void **ptr, char *_t)
#else
SWIGSTATIC
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
char *_SWIG_GetPtr(CPerl *pPerl, SV *sv, void **ptr, char *_t)
#endif
{
  char temp_type[256];
  char *name,*_c;
  int  len,i,start,end;
  IV   tmp;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;

  /* If magical, apply more magic */

  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return "Not a valid pointer value";
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return (char *) 0;
    }
  } else if (sv == &sv_undef) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return (char *) 0;
  } else if (SvTYPE(sv) == SVt_RV) {       /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return (char *) 0;
    else
      return "Not a valid pointer value";
  } else {                                 /* Don't know what it is */
      *(ptr) = (void *) 0;
      return "Not a valid pointer value";
  }
  if (_t) {
    /* Now see if the types match */      

    if (!sv_isa(sv,_t)) {
      _c = HvNAME(SvSTASH(SvRV(sv)));
      if (!SwigPtrSort) {
	qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort);  
	for (i = 0; i < 256; i++) {
	  SwigStart[i] = SwigPtrN;
	}
	for (i = SwigPtrN-1; i >= 0; i--) {
	  SwigStart[SwigPtrTable[i].name[0]] = i;
	}
	for (i = 255; i >= 1; i--) {
	  if (SwigStart[i-1] > SwigStart[i])
	    SwigStart[i-1] = SwigStart[i];
	}
	SwigPtrSort = 1;
	for (i = 0; i < SWIG_CACHESIZE; i++)  
	  SwigCache[i].stat = 0;
      }
      /* First check cache for matches.  Uses last cache value as starting point */
      cache = &SwigCache[SwigLastCache];
      for (i = 0; i < SWIG_CACHESIZE; i++) {
	if (cache->stat) {
	  if (strcmp(_t,cache->name) == 0) {
	    if (strcmp(_c,cache->mapped) == 0) {
	      cache->stat++;
	      *ptr = (void *) tmp;
	      if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
	      return (char *) 0;
	    }
	  }
	}
	SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	if (!SwigLastCache) cache = SwigCache;
	else cache++;
      }

      start = SwigStart[_t[0]];
      end = SwigStart[_t[0]+1];
      sp = &SwigPtrTable[start];
      while (start < end) {
	if (swigcmp(_t,sp) == 0) break;
	sp++;
	start++;
      }
      if (start >= end) sp = 0;
      if (sp) {
	while (swigcmp(_t,sp) == 0) {
	  name = sp->name;
	  len = sp->len;
	  tp = sp->next;
	  while(tp) {
	    if (tp->len >= 255) {
	      return _c;
	    }
	    strcpy(temp_type,tp->name);
	    strncat(temp_type,_t+len,255-tp->len);
	    if (sv_isa(sv,temp_type)) {
	      /* Get pointer value */
	      *ptr = (void *) tmp;
	      if (tp->cast) *ptr = (*(tp->cast))(*ptr);

	      strcpy(SwigCache[SwigCacheIndex].mapped,_c);
	      strcpy(SwigCache[SwigCacheIndex].name,_t);
	      SwigCache[SwigCacheIndex].stat = 1;
	      SwigCache[SwigCacheIndex].tp = tp;
	      SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
	      return (char *) 0;
	    }
	    tp = tp->next;
	  } 
	  /* Hmmm. Didn't find it this time */
 	  sp++;
	}
      }
      /* Didn't find any sort of match for this data.  
	 Get the pointer value and return the received type */
      *ptr = (void *) tmp;
      return _c;
    } else {
      /* Found a match on the first try.  Return pointer value */
      *ptr = (void *) tmp;
      return (char *) 0;
    }
  } 
  *ptr = (void *) tmp;
  return (char *) 0;
}

/* Compatibility mode */

#define _swig_get_hex  SWIG_GetPtr
/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerl *pPerl, SV *sv, char *name, int (CPerl::*set)(SV *, MAGIC *), int (CPerl::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = get;
  mg->mg_virtual->svt_set = set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

#define SWIG_init    boot_mfile

#define SWIG_name   "mfilec::boot_mfile"
#define SWIG_varinit "mfilec::var_mfile_init();"
#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
SWIGEXPORT(void,boot_mfile)(CV* cv);
#else
SWIGEXPORT(void,boot_mfile)(CPerl *, CV *cv);
#endif

#include <local/mfile.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "bs_visus_lib.h"


#ifdef WIN32
#undef isspace
#define isspace(c) (c == ' ')
#endif

/*------------------------------------------------------------------
  ptrcast(value,type)

  Constructs a new pointer value.   Value may either be a string
  or an integer. Type is a string corresponding to either the
  C datatype or mangled datatype.

  ptrcast(0,"Vector *")
               or
  ptrcast(0,"Vector_p")   
  ------------------------------------------------------------------ */
#ifdef PERL_OBJECT
static SV *_ptrcast(CPerl *pPerl, SV *_PTRVALUE, char *type) {
#define ptrcast(a,b)  _ptrcast(pPerl,a,b)
#else
static SV *_ptrcast(SV *_PTRVALUE, char *type) {
#define ptrcast(a,b)  _ptrcast(a,b)
#endif
  char *r,*s;
  void *ptr;
  SV *obj;
  char *typestr,*c;

  /* Produce a "mangled" version of the type string.  */

  typestr = (char *) malloc(strlen(type)+20);

  /* Go through and munge the typestring */
  
  r = typestr;
  c = type;
  while (*c) {
    if (!isspace(*c)) {
      if ((*c == '*') || (*c == '&')) {
	strcpy(r,"Ptr");
	r+=3;
      } else *(r++) = *c;
    } 
    c++;
  }
  *(r++) = 0;
    
  /* Check to see if the input value is an integer */
  if (SvIOK(_PTRVALUE)) {
    ptr = (void *) SvIV(_PTRVALUE);
    /* Received a numerical value. Make a pointer out of it */
    obj = sv_newmortal();
    sv_setref_pv(obj,typestr,ptr);
  } else if (sv_isobject(_PTRVALUE)) {
    /* Have a real pointer value now.  Try to strip out the pointer value */
    /* Now extract the pointer value */
    if (!SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
      obj = sv_newmortal();
      sv_setref_pv(obj,typestr,ptr);
    }
  } else {
    croak("ptrcast(). Not a reference.");
  }
  free(typestr);
  return obj;
}



/*------------------------------------------------------------------
  ptrvalue(ptr,type = 0)

  Attempts to dereference a pointer value.  If type is given, it 
  will try to use that type.  Otherwise, this function will attempt
  to "guess" the proper datatype by checking against all of the 
  builtin C datatypes. 
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static SV *_ptrvalue(CPerl *pPerl,SV *_PTRVALUE, int index, char *type) {
#define ptrvalue(a,b,c) _ptrvalue(pPerl,a,b,c)
#else
static SV *_ptrvalue(SV *_PTRVALUE, int index, char *type) {
#define ptrvalue(a,b,c) _ptrvalue(a,b,c)
#endif

  void     *ptr;
  SV       *obj = 0;


  if (SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    croak("Type error it ptrvalue. Argument is not a valid pointer value.");
  } else {
    /* If no datatype was passed, try a few common datatypes first */
    if (!type) {

      /* No datatype was passed.   Type to figure out if it's a common one */
      
      if (!SWIG_GetPtr(_PTRVALUE,&ptr,"intPtr")) {
	type = "int";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"doublePtr")) {
	type = "double";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"shortPtr")) {
	type = "short";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"longPtr")) {
	type = "long";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"floatPtr")) {
	type = "float";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtr")) {
	type = "char";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtrPtr")) {
	type = "char *";
      } else {
	type = "unknown";
      }
    }
    
    if (!ptr) {
      croak("Unable to dereference NULL pointer.");
      return 0;
    }

    /* Now we have a datatype.  Try to figure out what to do about it */
    if (strcmp(type,"int") == 0) {
      obj = sv_newmortal();
      sv_setiv(obj,(IV) *(((int *) ptr) + index));
    } else if (strcmp(type,"double") == 0) {
      obj = sv_newmortal();
      sv_setnv(obj,(double) *(((double *) ptr)+index));
    } else if (strcmp(type,"short") == 0) {
      obj = sv_newmortal();
      sv_setiv(obj,(IV) *(((short *) ptr) + index));
    } else if (strcmp(type,"long") == 0) {
      obj = sv_newmortal();
      sv_setiv(obj,(IV) *(((long *) ptr) + index));
    } else if (strcmp(type,"float") == 0) {
      obj = sv_newmortal();
      sv_setnv(obj,(double) *(((float *) ptr)+index));
    } else if (strcmp(type,"char") == 0) {
      obj = sv_newmortal();
      sv_setpv(obj,((char *) ptr)+index);
    } else if (strcmp(type,"char *") == 0) {
      char *c = *(((char **) ptr)+index);
      obj = sv_newmortal();
      if (c) 
	sv_setpv(obj,c);
      else 
	sv_setpv(obj,"NULL");
    } else {
      croak("Unable to dereference unsupported datatype.");
      obj = 0;
    }
  }
  return obj;
}

/*------------------------------------------------------------------
  ptrcreate(type,value = 0,numelements = 1)

  Attempts to create a new object of given type.  Type must be
  a basic C datatype.  Will not create complex objects.
  ------------------------------------------------------------------ */
#ifdef PERL_OBJECT
static SV *_ptrcreate(CPerl *pPerl, char *type, SV *value, int numelements) {
#define ptrcreate(a,b,c) _ptrcreate(pPerl,a,b,c)
#else
static SV *_ptrcreate(char *type, SV *value, int numelements) {
#define ptrcreate(a,b,c) _ptrcreate(a,b,c)
#endif

  void     *ptr;
  SV       *obj;
  int       sz;
  char     *cast;
  char      temp[40];

  /* Check the type string against a variety of possibilities */

  if (strcmp(type,"int") == 0) {
    sz = sizeof(int)*numelements;
    cast = "intPtr";
  } else if (strcmp(type,"short") == 0) {
    sz = sizeof(short)*numelements;
    cast = "shortPtr";
  } else if (strcmp(type,"long") == 0) {
    sz = sizeof(long)*numelements;
    cast = "longPtr";
  } else if (strcmp(type,"double") == 0) {
    sz = sizeof(double)*numelements;
    cast = "doublePtr";
  } else if (strcmp(type,"float") == 0) {
    sz = sizeof(float)*numelements;
    cast = "floatPtr";
  } else if (strcmp(type,"char") == 0) {
    sz = sizeof(char)*numelements;
    cast = "charPtr";
  } else if (strcmp(type,"char *") == 0) {
    sz = sizeof(char *)*(numelements+1);
    cast = "charPtrPtr";
  } else if (strcmp(type,"void") == 0) {
    sz = numelements;
    cast = "voidPtr";
  } else {
    croak("Unable to create unknown datatype."); 
    return 0;
  }
   
  /* Create the new object */
  
  ptr = (void *) malloc(sz);
  if (!ptr) {
    croak("Out of memory in ptrcreate."); 
    return 0;
  }

  /* Now try to set its default value */

  if (value) {
    if (strcmp(type,"int") == 0) {
      int *ip,i,ivalue;
      ivalue = (int) SvIV(value);
      ip = (int *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"short") == 0) {
      short *ip,ivalue;
      int i;
      ivalue = (short) SvIV(value);
      ip = (short *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"long") == 0) {
      long *ip,ivalue;
      int i;
      ivalue = (long) SvIV(value);
      ip = (long *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"double") == 0) {
      double *ip,ivalue;
      int i;
      ivalue = (double) SvNV(value);
      ip = (double *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"float") == 0) {
      float *ip,ivalue;
      int i;
      ivalue = (float) SvNV(value);
      ip = (float *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"char") == 0) {
      char *ip,*ivalue;
      ivalue = (char *) SvPV(value,na);
      ip = (char *) ptr;
      strncpy(ip,ivalue,numelements-1);
    } else if (strcmp(type,"char *") == 0) {
      char **ip, *ivalue;
      int  i;
      ivalue = (char *) SvPV(value,na);
      ip = (char **) ptr;
      for (i = 0; i < numelements; i++) {
	if (ivalue) {
	  ip[i] = (char *) malloc(strlen(ivalue)+1);
	  strcpy(ip[i],ivalue);
	} else {
	  ip[i] = 0;
	}
      }
      ip[numelements] = 0;
    }
  } 
  /* Create the pointer value */
  
  SWIG_MakePtr(temp,ptr,cast);
  obj = sv_newmortal();
  sv_setref_pv(obj,cast,ptr);
  return obj;
}

/*------------------------------------------------------------------
  ptrset(ptr,value,index = 0,type = 0)

  Attempts to set the value of a pointer variable.  If type is
  given, we will use that type.  Otherwise, we'll guess the datatype.
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static void _ptrset(CPerl *pPerl,SV *_PTRVALUE, SV *value, int index, char *type) {
#define ptrset(a,b,c,d) _ptrset(pPerl,a,b,c,d)
#else
static void _ptrset(SV *_PTRVALUE, SV *value, int index, char *type) {
#define ptrset(a,b,c,d) _ptrset(a,b,c,d)
#endif
  void     *ptr;
  SV       *obj;

  if (SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    croak("Type error in ptrset. Argument is not a valid pointer value.");
    return;
  }

  /* If no datatype was passed, try a few common datatypes first */

  if (!type) {

    /* No datatype was passed.   Type to figure out if it's a common one */

    if (!SWIG_GetPtr(_PTRVALUE,&ptr,"intPtr")) {
      type = "int";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"doublePtr")) {
      type = "double";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"shortPtr")) {
      type = "short";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"longPtr")) {
      type = "long";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"floatPtr")) {
      type = "float";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtr")) {
      type = "char";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtrPtr")) {
      type = "char *";
    } else {
      type = "unknown";
    }
  }

  if (!ptr) {
    croak("Unable to set NULL pointer.");
    return;
  }
  
  /* Now we have a datatype.  Try to figure out what to do about it */
  if (strcmp(type,"int") == 0) {
    *(((int *) ptr)+index) = (int) SvIV(value);
  } else if (strcmp(type,"double") == 0) {
    *(((double *) ptr)+index) = (double) SvNV(value);
  } else if (strcmp(type,"short") == 0) {
    *(((short *) ptr)+index) = (short) SvIV(value);
  } else if (strcmp(type,"long") == 0) {
    *(((long *) ptr)+index) = (long) SvIV(value);
  } else if (strcmp(type,"float") == 0) {
    *(((float *) ptr)+index) = (float) SvNV(value);
  } else if (strcmp(type,"char") == 0) {
    char *c = SvPV(value,na);
    strcpy(((char *) ptr)+index, c);
  } else if (strcmp(type,"char *") == 0) {
    char *c = SvPV(value,na);
    char **ca = (char **) ptr;
    if (ca[index]) free(ca[index]);
    if (strcmp(c,"NULL") == 0) {
      ca[index] = 0;
    } else {
      ca[index] = (char *) malloc(strlen(c)+1);
      strcpy(ca[index],c);
    }
  } else {
    croak("Unable to set unsupported datatype.");
    return;
  }
}

/*------------------------------------------------------------------
  ptradd(ptr,offset)

  Adds a value to an existing pointer value.  Will do a type-dependent
  add for basic datatypes.  For other datatypes, will do a byte-add.
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static SV *_ptradd(CPerl *pPerl, SV *_PTRVALUE, int offset) {
#define ptradd(a,b) _ptradd(pPerl,a,b)
#else
static SV *_ptradd(SV *_PTRVALUE, int offset) {
#define ptradd(a,b) _ptradd(a,b)
#endif

  void *ptr,*junk;
  SV   *obj;
  char *type;

  /* Try to handle a few common datatypes first */

  if (!SWIG_GetPtr(_PTRVALUE,&ptr,"intPtr")) {
    ptr = (void *) (((int *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"doublePtr")) {
    ptr = (void *) (((double *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"shortPtr")) {
    ptr = (void *) (((short *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"longPtr")) {
    ptr = (void *) (((long *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"floatPtr")) {
    ptr = (void *) (((float *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtr")) {
    ptr = (void *) (((char *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    ptr = (void *) (((char *) ptr) + offset);
  } else {
    croak("Type error in ptradd. Argument is not a valid pointer value.");
    return 0;
  }
  type = SWIG_GetPtr(_PTRVALUE,&junk,"INVALID POINTER");
  obj = sv_newmortal();
  sv_setref_pv(obj,type,ptr);
  return obj;
}

/*------------------------------------------------------------------
  ptrmap(type1,type2)

  Allows a mapping between type1 and type2. (Like a typedef)
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static void _ptrmap(CPerl *pPerl,char *type1, char *type2) {
#define ptrmap(a,b) _ptrmap(pPerl,a,b)
#else
static void _ptrmap(char *type1, char *type2) {
#define ptrmap(a,b) _ptrmap(a,b)
#endif
  char *typestr1,*typestr2,*c,*r;
  /* Produce a "mangled" version of the type string.  */

  typestr1 = (char *) malloc(strlen(type1)+20);


  /* Go through and munge the typestring */
  
  r = typestr1;
  *(r++) = '_';
  c = type1;

  while (*c) {
    if (!isspace(*c)) {
      if ((*c == '*') || (*c == '&')) {
	strcpy(r,"Ptr");
	r+=3;
      }
      else *(r++) = *c;
    } 
    c++;
  }
  *(r++) = 0;

  typestr2 = (char *) malloc(strlen(type2)+20);

  /* Go through and munge the typestring */
  
  r = typestr2;
  *(r++) = '_';
  c = type2;
  while (*c) {
    if (!isspace(*c)) {
      if ((*c == '*') || (*c == '&')) {
	strcpy(r,"Ptr");
	r+=3;
      }
      else *(r++) = *c;
    }
    c++;
  }
  *(r++) = 0;
  SWIG_RegisterMapping(typestr1,typestr2,0);
  SWIG_RegisterMapping(typestr2,typestr1,0);
}

/*------------------------------------------------------------------
  ptrfree(ptr)

  Destroys a pointer value
  ------------------------------------------------------------------ */
#ifdef PERL_OBJECT
void _ptrfree(CPerl *pPerl, SV *_PTRVALUE) {
#define ptrfree(a) _ptrfree(pPerl, a)
#else
void _ptrfree(SV *_PTRVALUE) {
#define ptrfree(a) _ptrfree(a)
#endif

  void *ptr, *junk;

  if (SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    croak("Type error in ptrfree. Argument is not a valid pointer value.");
    return;
  }

  /* Check to see if this pointer is a char ** */
  if (!SWIG_GetPtr(_PTRVALUE,&junk,"charPtrPtr")) {
    char **c = (char **) ptr;
    if (c) {
      int i = 0;
      while (c[i]) {
	free(c[i]);
	i++;
      }
    }
  } 
  if (ptr)
    free((char *) ptr);
}


int 
get_size (char* mtxfile) {
  MFILE* mtx;
  minfo info;

  mtx = mopen(mtxfile, "r");
  if (!mtx) {
    printf("Cannot open %s\n", mtxfile);
    exit(1);
  }

  mgetinfo(mtx, &info);

  mclose(mtx);

  return (info.columns);
}  

int add_spec (unsigned long *spec, unsigned long *add, int size) {
   int i;
   for (i = 0; i < size; i++) {
      spec[i] += add[i];
   }	   
}

int
recal_poly (long* spectrum, int size, double* pol, int polsize) 
{
  int i;
  long* helpspec;
  double cal;

  helpspec = (long*) calloc(size, sizeof(int));
  
  if (polsize < 2) {
    printf("Not a suitable Polynomsize, need at least two parameters\n");
    return(0);
  }
  
  cal = pol[0];
  for (i = 0; i < size; i++) {
    double nextcal;
    double width;
    double k;
    int calrnd;
    int nextcalrnd;
    int grad;

    k = i + .5;   /* using tv channels from c-.5 to c+.5 */

    nextcal = pol[polsize-1]; 
    for (grad = (polsize - 2); grad > -1; grad--) {
      double mycal = k * nextcal + pol[grad];
      nextcal = mycal;
    }

    calrnd = (int)(cal + .5);
    nextcalrnd = (int)(nextcal + .5);

    width = nextcal - cal;

    if ( (cal >= size) || (cal < 0) || (nextcal >= size) || (nextcal < 0)) {
      cal = nextcal;
      continue;
    }

    if (nextcal >= (calrnd + .5)) {
      /* Ueberschreitung einer Grenze */
      int j;
      double height1;
      
      height1 = spectrum[i] / width;
      /* proz. Anteil des Vorgrenzteils */
      helpspec[calrnd] += (long) ((calrnd + .5 - cal) * height1 + .5);
      for (j = calrnd + 1; j < nextcalrnd; j++) {
	/* Ueberschreitung mehrerer Grenzen */
	helpspec[j] += (long) (height1 + .5);
      }
      /* proz. Anteil des Nachgrenzteils zum naechsten Kanal */
      helpspec[nextcalrnd] +=
	(long) ((nextcal - (nextcalrnd - .5)) * height1 + .5);
    } else {
      helpspec[calrnd] += spectrum[i];
    }
    cal = nextcal;
  }

  for (i = 0; i < size; i++) {
    spectrum[i] = helpspec[i];
  }
  free(helpspec);
  return(1);
}

int
recal_pair (long* spectrum, int size, double a, double b, double c,
	    double d)
{
  double pol[2];
  int polsize = 2;

  if (c == a) {
    fprintf (stderr, "Pair-Recalibration-Error! Equal channels!\n");
    return 0;
  }

  pol[0] = ( c * b - d * a ) / ( c - a ) ;
  pol[1] = ( d - b ) / ( c - a ) ;

  if (!recal_poly (spectrum, size, pol, polsize)) {
    return(0);
  }
  return(1);
}
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_mfile_var::
class _wrap_mfile_var : public CPerl {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}


#ifdef PERL_OBJECT
};
#endif

XS(_wrap_ptrcast) {

    SV * _result;
    SV * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ptrcast(ptr,type);");
{
  _arg0 = ST(0);
}
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (SV *)ptrcast(_arg0,_arg1);
{
  ST(0) = _result;
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ptrvalue) {

    SV * _result;
    SV * _arg0;
    int  _arg1 = 0;
    char * _arg2 = 0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 3)) 
        croak("Usage: ptrvalue(ptr,index,type);");
{
  _arg0 = ST(0);
}
    if (items > 1) {
    _arg1 = (int )SvIV(ST(1));
    } 
    if (items > 2) {
    _arg2 = (char *) SvPV(ST(2),na);
    } 
    _result = (SV *)ptrvalue(_arg0,_arg1,_arg2);
{
  ST(0) = _result;
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ptrset) {

    SV * _arg0;
    SV * _arg1;
    int  _arg2 = 0;
    char * _arg3 = 0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 4)) 
        croak("Usage: ptrset(ptr,value,index,type);");
{
  _arg0 = ST(0);
}
{
  _arg1 = ST(1);
}
    if (items > 2) {
    _arg2 = (int )SvIV(ST(2));
    } 
    if (items > 3) {
    _arg3 = (char *) SvPV(ST(3),na);
    } 
    ptrset(_arg0,_arg1,_arg2,_arg3);
    XSRETURN(argvi);
}

XS(_wrap_ptrcreate) {

    SV * _result;
    char * _arg0;
    SV * _arg1 = 0;
    int  _arg2 = 1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 3)) 
        croak("Usage: ptrcreate(type,value,nitems);");
    _arg0 = (char *) SvPV(ST(0),na);
    if (items > 1) {
{
  _arg1 = ST(1);
}
    } 
    if (items > 2) {
    _arg2 = (int )SvIV(ST(2));
    } 
    _result = (SV *)ptrcreate(_arg0,_arg1,_arg2);
{
  ST(0) = _result;
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ptrfree) {

    SV * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: ptrfree(ptr);");
{
  _arg0 = ST(0);
}
    ptrfree(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_ptradd) {

    SV * _result;
    SV * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ptradd(ptr,offset);");
{
  _arg0 = ST(0);
}
    _arg1 = (int )SvIV(ST(1));
    _result = (SV *)ptradd(_arg0,_arg1);
{
  ST(0) = _result;
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ptrmap) {

    char * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ptrmap(type1,type2);");
    _arg0 = (char *) SvPV(ST(0),na);
    _arg1 = (char *) SvPV(ST(1),na);
    ptrmap(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_load_spec) {

    int  _result;
    char * _arg0;
    unsigned long * _arg1;
    int  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: load_spec(char *,unsigned long *,int );");
    _arg0 = (char *) SvPV(ST(0),na);
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"unsigned longPtr")) {
        croak("Type error in argument 2 of load_spec. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (int )load_spec(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_save_spec) {

    int  _result;
    char * _arg0;
    unsigned long * _arg1;
    int  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: save_spec(char *,unsigned long *,int );");
    _arg0 = (char *) SvPV(ST(0),na);
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"unsigned longPtr")) {
        croak("Type error in argument 2 of save_spec. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (int )save_spec(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_bs_shift) {

    int  _result;
    unsigned long * _arg0;
    unsigned long * _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    int  _arg7;
    int  _arg8;
    int  _arg9;
    float * _arg10;
    float * _arg11;
    float * _arg12;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 13) || (items > 13)) 
        croak("Usage: bs_shift(ref_spec,spec,res,NBSEG,flag_C,LOW_LIMIT_C,flag_H,HIGH_LIMIT,LOW_LIMIT,CMP_FAC,shift_koef_a,shift_koef_b,mean_least_square);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"unsigned longPtr")) {
        croak("Type error in argument 1 of bs_shift. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"unsigned longPtr")) {
        croak("Type error in argument 2 of bs_shift. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _arg4 = (int )SvIV(ST(4));
    _arg5 = (int )SvIV(ST(5));
    _arg6 = (int )SvIV(ST(6));
    _arg7 = (int )SvIV(ST(7));
    _arg8 = (int )SvIV(ST(8));
    _arg9 = (int )SvIV(ST(9));
    if (SWIG_GetPtr(ST(10),(void **) &_arg10,"floatPtr")) {
        croak("Type error in argument 11 of bs_shift. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(11),(void **) &_arg11,"floatPtr")) {
        croak("Type error in argument 12 of bs_shift. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(12),(void **) &_arg12,"floatPtr")) {
        croak("Type error in argument 13 of bs_shift. Expected floatPtr.");
        XSRETURN(1);
    }
    _result = (int )bs_shift(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11,_arg12);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_bs_shift_default) {

    int  _result;
    unsigned long * _arg0;
    unsigned long * _arg1;
    int  _arg2;
    float * _arg3;
    float * _arg4;
    float * _arg5;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 6) || (items > 6)) 
        croak("Usage: bs_shift_default(ref_spec,spec,res,shift_koef_a,shift_koef_b,mean_least_square);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"unsigned longPtr")) {
        croak("Type error in argument 1 of bs_shift_default. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"unsigned longPtr")) {
        croak("Type error in argument 2 of bs_shift_default. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"floatPtr")) {
        croak("Type error in argument 4 of bs_shift_default. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(4),(void **) &_arg4,"floatPtr")) {
        croak("Type error in argument 5 of bs_shift_default. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"floatPtr")) {
        croak("Type error in argument 6 of bs_shift_default. Expected floatPtr.");
        XSRETURN(1);
    }
    _result = (int )bs_shift_default(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_bs_shift_F) {

    int  _result;
    float * _arg0;
    int  _arg1;
    unsigned long * _arg2;
    int  _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    float * _arg7;
    float * _arg8;
    float * _arg9;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 10) || (items > 10)) 
        croak("Usage: bs_shift_F(man_pos_ref_float,M,spec,res,flag_C,LOW_LIMIT_C,CMP_FAC,shift_koef_a,shift_koef_b,mean_least_square);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"floatPtr")) {
        croak("Type error in argument 1 of bs_shift_F. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"unsigned longPtr")) {
        croak("Type error in argument 3 of bs_shift_F. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    _arg3 = (int )SvIV(ST(3));
    _arg4 = (int )SvIV(ST(4));
    _arg5 = (int )SvIV(ST(5));
    _arg6 = (int )SvIV(ST(6));
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of bs_shift_F. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(8),(void **) &_arg8,"floatPtr")) {
        croak("Type error in argument 9 of bs_shift_F. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(9),(void **) &_arg9,"floatPtr")) {
        croak("Type error in argument 10 of bs_shift_F. Expected floatPtr.");
        XSRETURN(1);
    }
    _result = (int )bs_shift_F(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_bs_shift_R) {

    int  _result;
    int * _arg0;
    int  _arg1;
    unsigned long * _arg2;
    unsigned long * _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    int  _arg7;
    int  _arg8;
    int  _arg9;
    int  _arg10;
    float * _arg11;
    float * _arg12;
    float * _arg13;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 14) || (items > 14)) 
        croak("Usage: bs_shift_R(max_pos_ref,M,ref_spec,spec,res,flag_C,LOW_LIMIT_C,flag_H,HIGH_LIMIT,LOW_LIMIT,CMP_FAC,shift_koef_a,shift_koef_b,mean_least_square);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"intPtr")) {
        croak("Type error in argument 1 of bs_shift_R. Expected intPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"unsigned longPtr")) {
        croak("Type error in argument 3 of bs_shift_R. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"unsigned longPtr")) {
        croak("Type error in argument 4 of bs_shift_R. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    _arg5 = (int )SvIV(ST(5));
    _arg6 = (int )SvIV(ST(6));
    _arg7 = (int )SvIV(ST(7));
    _arg8 = (int )SvIV(ST(8));
    _arg9 = (int )SvIV(ST(9));
    _arg10 = (int )SvIV(ST(10));
    if (SWIG_GetPtr(ST(11),(void **) &_arg11,"floatPtr")) {
        croak("Type error in argument 12 of bs_shift_R. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(12),(void **) &_arg12,"floatPtr")) {
        croak("Type error in argument 13 of bs_shift_R. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(13),(void **) &_arg13,"floatPtr")) {
        croak("Type error in argument 14 of bs_shift_R. Expected floatPtr.");
        XSRETURN(1);
    }
    _result = (int )bs_shift_R(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11,_arg12,_arg13);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_bs_shift_M) {

    int  _result;
    int * _arg0;
    int  _arg1;
    unsigned long * _arg2;
    unsigned long * _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    int  _arg7;
    int  _arg8;
    int  _arg9;
    int  _arg10;
    int  _arg11;
    float * _arg12;
    float * _arg13;
    float * _arg14;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 15) || (items > 15)) 
        croak("Usage: bs_shift_M(man_pos,M,ref_spec,spec,res,NBSEG,flag_C,LOW_LIMIT_C,flag_H,HIGH_LIMIT,LOW_LIMIT,CMP_FAC,shift_koef_a,shift_koef_b,mean_least_square);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"intPtr")) {
        croak("Type error in argument 1 of bs_shift_M. Expected intPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"unsigned longPtr")) {
        croak("Type error in argument 3 of bs_shift_M. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"unsigned longPtr")) {
        croak("Type error in argument 4 of bs_shift_M. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    _arg5 = (int )SvIV(ST(5));
    _arg6 = (int )SvIV(ST(6));
    _arg7 = (int )SvIV(ST(7));
    _arg8 = (int )SvIV(ST(8));
    _arg9 = (int )SvIV(ST(9));
    _arg10 = (int )SvIV(ST(10));
    _arg11 = (int )SvIV(ST(11));
    if (SWIG_GetPtr(ST(12),(void **) &_arg12,"floatPtr")) {
        croak("Type error in argument 13 of bs_shift_M. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(13),(void **) &_arg13,"floatPtr")) {
        croak("Type error in argument 14 of bs_shift_M. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(14),(void **) &_arg14,"floatPtr")) {
        croak("Type error in argument 15 of bs_shift_M. Expected floatPtr.");
        XSRETURN(1);
    }
    _result = (int )bs_shift_M(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11,_arg12,_arg13,_arg14);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_get_size) {

    int  _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: get_size(mtxfile);");
    _arg0 = (char *) SvPV(ST(0),na);
    _result = (int )get_size(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_add_spec) {

    int  _result;
    unsigned long * _arg0;
    unsigned long * _arg1;
    int  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: add_spec(spec,add,size);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"unsigned longPtr")) {
        croak("Type error in argument 1 of add_spec. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"unsigned longPtr")) {
        croak("Type error in argument 2 of add_spec. Expected unsigned longPtr.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (int )add_spec(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_recal_poly) {

    int  _result;
    long * _arg0;
    int  _arg1;
    double * _arg2;
    int  _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: recal_poly(spectrum,size,pol,polsize);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"longPtr")) {
        croak("Type error in argument 1 of recal_poly. Expected longPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"doublePtr")) {
        croak("Type error in argument 3 of recal_poly. Expected doublePtr.");
        XSRETURN(1);
    }
    _arg3 = (int )SvIV(ST(3));
    _result = (int )recal_poly(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_recal_pair) {

    int  _result;
    long * _arg0;
    int  _arg1;
    double  _arg2;
    double  _arg3;
    double  _arg4;
    double  _arg5;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 6) || (items > 6)) 
        croak("Usage: recal_pair(spectrum,size,a,b,c,d);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"longPtr")) {
        croak("Type error in argument 1 of recal_pair. Expected longPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _arg3 = (double ) SvNV(ST(3));
    _arg4 = (double ) SvNV(ST(4));
    _arg5 = (double ) SvNV(ST(5));
    _result = (int )recal_pair(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_perl5_mfile_var_init) {
    dXSARGS;
    SV *sv;
    cv = cv; items = items;
    XSRETURN(1);
}
#ifdef __cplusplus
extern "C"
#endif
XS(boot_mfile) {
	 dXSARGS;
	 char *file = __FILE__;
	 cv = cv; items = items;
	 newXS("mfilec::var_mfile_init", _wrap_perl5_mfile_var_init, file);
	 newXS("mfilec::ptrcast", _wrap_ptrcast, file);
	 newXS("mfilec::ptrvalue", _wrap_ptrvalue, file);
	 newXS("mfilec::ptrset", _wrap_ptrset, file);
	 newXS("mfilec::ptrcreate", _wrap_ptrcreate, file);
	 newXS("mfilec::ptrfree", _wrap_ptrfree, file);
	 newXS("mfilec::ptradd", _wrap_ptradd, file);
	 newXS("mfilec::ptrmap", _wrap_ptrmap, file);
	 newXS("mfilec::load_spec", _wrap_load_spec, file);
	 newXS("mfilec::save_spec", _wrap_save_spec, file);
	 newXS("mfilec::bs_shift", _wrap_bs_shift, file);
	 newXS("mfilec::bs_shift_default", _wrap_bs_shift_default, file);
	 newXS("mfilec::bs_shift_F", _wrap_bs_shift_F, file);
	 newXS("mfilec::bs_shift_R", _wrap_bs_shift_R, file);
	 newXS("mfilec::bs_shift_M", _wrap_bs_shift_M, file);
	 newXS("mfilec::get_size", _wrap_get_size, file);
	 newXS("mfilec::add_spec", _wrap_add_spec, file);
	 newXS("mfilec::recal_poly", _wrap_recal_poly, file);
	 newXS("mfilec::recal_pair", _wrap_recal_pair, file);
/*
 * These are the pointer type-equivalency mappings. 
 * (Used by the SWIG pointer type-checker).
 */
	 SWIG_RegisterMapping("unsigned short","short",0);
	 SWIG_RegisterMapping("long","unsigned long",0);
	 SWIG_RegisterMapping("long","signed long",0);
	 SWIG_RegisterMapping("signed short","short",0);
	 SWIG_RegisterMapping("signed int","int",0);
	 SWIG_RegisterMapping("short","unsigned short",0);
	 SWIG_RegisterMapping("short","signed short",0);
	 SWIG_RegisterMapping("unsigned long","long",0);
	 SWIG_RegisterMapping("int","unsigned int",0);
	 SWIG_RegisterMapping("int","signed int",0);
	 SWIG_RegisterMapping("unsigned int","int",0);
	 SWIG_RegisterMapping("signed long","long",0);
	 ST(0) = &sv_yes;
	 XSRETURN(1);
}
