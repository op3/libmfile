head	1.9;
access;
symbols;
locks;
comment	@ * @;


1.9
date	93.07.20.17.58.45;	author se;	state Exp;
branches;
next	1.8;

1.8
date	93.04.22.15.26.28;	author se;	state Exp;
branches;
next	1.7;

1.7
date	92.07.30.12.09.41;	author se;	state Exp;
branches;
next	1.6;

1.6
date	92.07.25.14.16.20;	author se;	state Exp;
branches;
next	1.5;

1.5
date	92.03.31.02.05.47;	author se;	state Exp;
branches;
next	1.4;

1.4
date	92.02.17.23.15.32;	author se;	state Exp;
branches;
next	1.3;

1.3
date	92.02.14.19.05.34;	author se;	state Exp;
branches;
next	1.2;

1.2
date	92.02.13.14.37.45;	author se;	state Exp;
branches;
next	1.1;

1.1
date	92.02.03.17.38.25;	author se;	state Exp;
branches;
next	;


desc
@read and write interger data for compatibility with traditional matrix files
@


1.9
log
@modified for use with access method module
@
text
@/*
 * oldmat_getput.c:	Copyright 1992 by 
 *			Stefan Esser
 *			Institut for Nuclear Physics
 *			University of Cologne, Germany
 *
 */

#include <string.h>

#include "mfile.h"
#include "getputint.h"
#include "oldmat_getput.h"

static char rcsid[] = "$Id: oldmat_getput.c,v 1.8 1993/04/22 15:26:28 se Exp $";

/* $Log: oldmat_getput.c,v $
 * Revision 1.8  1993/04/22  15:26:28  se
 * Support added for SIGNED 2 byte integer data
 *
 * Revision 1.7  1992/07/30  12:09:41  se
 * added copyright note
 *
 * Revision 1.6  1992/07/25  14:16:20  se
 * added subroutines to get and put data from triagonal matrizes
 *
 * Revision 1.5  1992/03/31  02:05:47  se
 * added casts to (int *) to calls of {get,put}{le,he}{4,8}()
 *
 * Revision 1.4  1992/02/17  23:15:32  se
 * added functions to read low and high endian 8 byte float matrixes
 *
 * Revision 1.3  1992/02/14  19:05:34  se
 * first implementation of (trivial) floating point spectra and matrices
 *
 * Revision 1.2  1992/02/13  14:37:45  se
 * added rcsid[]
 *
 */


#define fpos(s) (((level * mat->lines + line) * mat->columns + col) * (s))

#define tri_pos(l,c) (( (l * (l+1)) >> 1) + c)

#define fpos_t(s) ((level * tri_pos(mat->lines,0) + tri_pos(line, col)) * (s))

int le4_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  return getle4 (mat->ap, buffer, fpos (4), num);
}

int le4_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  return putle4 (mat->ap, buffer, fpos (4), num);
}

int le2_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  return getle2 (mat->ap, buffer, fpos (2), num);
}

int le2_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  return putle2 (mat->ap, buffer, fpos (2), num);
}

int le2s_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  return getle2s (mat->ap, buffer, fpos (2), num);
}

int he4_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  return gethe4 (mat->ap, buffer, fpos (4), num);
}

int he4_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  return puthe4 (mat->ap, buffer, fpos (4), num);
}

int he2_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  return gethe2 (mat->ap, buffer, fpos (2), num);
}

int he2s_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  return gethe2s (mat->ap, buffer, fpos (2), num);
}

int he2_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  return puthe2 (mat->ap, buffer, fpos (2), num);
}

/*----------------------------------------------------------------------*/

int le4t_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  int ndata, nzero;
  int res;

  ndata = line +1 - col;
  if (ndata < 0) ndata = 0;
  if (ndata > num) ndata = num;
  nzero = num - ndata;

  if ((res = getle4 (mat->ap, buffer, fpos_t (4), (unsigned) ndata)) < ndata) return res;
  memset (buffer +ndata, 0, nzero * sizeof(*buffer));

  return num;
}

int le4t_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  int ndata;
  int res;
  int i;

  ndata = line +1 - col;
  if (ndata < 0) ndata = 0;
  if (ndata > num) ndata = num;

  if ((res = putle4 (mat->ap, buffer, fpos_t (4), (unsigned) ndata)) < ndata) return res;

  for (i = ndata; i < num; i++) {
    if (*(buffer +i) != 0) return i;
  }

  return num;
}

int le2t_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  int ndata, nzero;
  int res;

  ndata = line +1 - col;
  if (ndata < 0) ndata = 0;
  if (ndata > num) ndata = num;
  nzero = num - ndata;

  if ((res = getle2 (mat->ap, buffer, fpos_t (2), (unsigned) ndata)) < ndata) return res;
  memset (buffer +ndata, 0, nzero * sizeof(*buffer));

  return num;
}

int le2t_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  int ndata;
  int res;
  int i;

  ndata = line +1 - col;
  if (ndata < 0) ndata = 0;
  if (ndata > num) ndata = num;

  if ((res = putle2 (mat->ap, buffer, fpos_t (2), (unsigned) ndata)) < ndata) return res;

  for (i = ndata; i < num; i++) {
    if (*(buffer +i) != 0) return i;
  }

  return num;
}

int he4t_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  int ndata, nzero;
  int res;

  ndata = line +1 - col;
  if (ndata < 0) ndata = 0;
  if (ndata > num) ndata = num;
  nzero = num - ndata;

  if ((res = gethe4 (mat->ap, buffer, fpos_t (4), (unsigned) ndata)) < ndata) return res;
  memset (buffer +ndata, 0, nzero * sizeof(*buffer));

  return num;
}

int he4t_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  int ndata;
  int res;
  int i;

  ndata = line +1 - col;
  if (ndata < 0) ndata = 0;
  if (ndata > num) ndata = num;

  if ((res = puthe4 (mat->ap, buffer, fpos_t (4), (unsigned) ndata)) < ndata) return res;

  for (i = ndata; i < num; i++) {
    if (*(buffer +i) != 0) return i;
  }

  return num;
}

int he2t_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  int ndata, nzero;
  int res;

  ndata = line +1 - col;
  if (ndata < 0) ndata = 0;
  if (ndata > num) ndata = num;
  nzero = num - ndata;

  if ((res = gethe2 (mat->ap, buffer, fpos_t (2), (unsigned) ndata)) < ndata) return res;
  memset (buffer +ndata, 0, nzero * sizeof(*buffer));

  return num;
}

int he2t_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  int ndata;
  int res;
  int i;

  ndata = line +1 - col;
  if (ndata < 0) ndata = 0;
  if (ndata > num) ndata = num;

  if ((res = puthe2 (mat->ap, buffer, fpos_t (2), (unsigned) ndata)) < ndata) return res;

  for (i = ndata; i < num; i++) {
    if (*(buffer +i) != 0) return i;
  }

  return num;
}

/*----------------------------------------------------------------------*/

int lf4_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     float *buffer;
{
  return getle4 (mat->ap, (int *)buffer, fpos (4), num);
}

int lf4_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     float *buffer;
{
  return putle4 (mat->ap, (int *)buffer, fpos (4), num);
}

int hf4_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     float *buffer;
{
  return gethe4 (mat->ap, (int *)buffer, fpos (4), num);
}

int hf4_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     float *buffer;
{
  return puthe4 (mat->ap, (int *)buffer, fpos (4), num);
}

/*----------------------------------------------------------------------*/

int lf8_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     double *buffer;
{
  return getle8 (mat->ap, (int *)buffer, fpos (4), num);
}

int lf8_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     double *buffer;
{
  return putle8 (mat->ap, (int *)buffer, fpos (4), num);
}

int hf8_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     double *buffer;
{
  return gethe8 (mat->ap, (int *)buffer, fpos (4), num);
}

int hf8_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     double *buffer;
{
  return puthe8 (mat->ap, (int *)buffer, fpos (4), num);
}

@


1.8
log
@Support added for SIGNED 2 byte integer data
@
text
@d15 1
a15 1
static char rcsid[] = "$Id: oldmat_getput.c,v 1.7 1992/07/30 12:09:41 se Exp $";
d18 3
d53 1
a53 1
  return getle4 (mat->fd, buffer, fpos (4), num);
d61 1
a61 1
  return putle4 (mat->fd, buffer, fpos (4), num);
d69 1
a69 1
  return getle2 (mat->fd, buffer, fpos (2), num);
d77 1
a77 1
  return putle2 (mat->fd, buffer, fpos (2), num);
d85 1
a85 1
  return getle2s (mat->fd, buffer, fpos (2), num);
d93 1
a93 1
  return gethe4 (mat->fd, buffer, fpos (4), num);
d101 1
a101 1
  return puthe4 (mat->fd, buffer, fpos (4), num);
d109 1
a109 1
  return gethe2 (mat->fd, buffer, fpos (2), num);
d117 1
a117 1
  return gethe2s (mat->fd, buffer, fpos (2), num);
d125 1
a125 1
  return puthe2 (mat->fd, buffer, fpos (2), num);
d143 1
a143 1
  if ((res = getle4 (mat->fd, buffer, fpos_t (4), (unsigned) ndata)) < ndata) return res;
d162 1
a162 1
  if ((res = putle4 (mat->fd, buffer, fpos_t (4), (unsigned) ndata)) < ndata) return res;
d184 1
a184 1
  if ((res = getle2 (mat->fd, buffer, fpos_t (2), (unsigned) ndata)) < ndata) return res;
d203 1
a203 1
  if ((res = putle2 (mat->fd, buffer, fpos_t (2), (unsigned) ndata)) < ndata) return res;
d225 1
a225 1
  if ((res = gethe4 (mat->fd, buffer, fpos_t (4), (unsigned) ndata)) < ndata) return res;
d244 1
a244 1
  if ((res = puthe4 (mat->fd, buffer, fpos_t (4), (unsigned) ndata)) < ndata) return res;
d266 1
a266 1
  if ((res = gethe2 (mat->fd, buffer, fpos_t (2), (unsigned) ndata)) < ndata) return res;
d285 1
a285 1
  if ((res = puthe2 (mat->fd, buffer, fpos_t (2), (unsigned) ndata)) < ndata) return res;
d301 1
a301 1
  return getle4 (mat->fd, (int *)buffer, fpos (4), num);
d309 1
a309 1
  return putle4 (mat->fd, (int *)buffer, fpos (4), num);
d317 1
a317 1
  return gethe4 (mat->fd, (int *)buffer, fpos (4), num);
d325 1
a325 1
  return puthe4 (mat->fd, (int *)buffer, fpos (4), num);
d335 1
a335 1
  return getle8 (mat->fd, (int *)buffer, fpos (4), num);
d343 1
a343 1
  return putle8 (mat->fd, (int *)buffer, fpos (4), num);
d351 1
a351 1
  return gethe8 (mat->fd, (int *)buffer, fpos (4), num);
d359 1
a359 1
  return puthe8 (mat->fd, (int *)buffer, fpos (4), num);
@


1.7
log
@added copyright note
@
text
@d15 1
a15 1
static char rcsid[] = "$Id: oldmat_getput.c,v 1.6 1992/07/25 14:16:20 se Exp $";
d18 3
d77 8
d109 8
d140 1
a140 1
  if ((res = getle4 (mat->fd, buffer, fpos_t (4), ndata)) < ndata) return res;
d159 1
a159 1
  if ((res = putle4 (mat->fd, buffer, fpos_t (4), ndata)) < ndata) return res;
d181 1
a181 1
  if ((res = getle2 (mat->fd, buffer, fpos_t (2), ndata)) < ndata) return res;
d200 1
a200 1
  if ((res = putle2 (mat->fd, buffer, fpos_t (2), ndata)) < ndata) return res;
d222 1
a222 1
  if ((res = gethe4 (mat->fd, buffer, fpos_t (4), ndata)) < ndata) return res;
d241 1
a241 1
  if ((res = puthe4 (mat->fd, buffer, fpos_t (4), ndata)) < ndata) return res;
d263 1
a263 1
  if ((res = gethe2 (mat->fd, buffer, fpos_t (2), ndata)) < ndata) return res;
d282 1
a282 1
  if ((res = puthe2 (mat->fd, buffer, fpos_t (2), ndata)) < ndata) return res;
@


1.6
log
@added subroutines to get and put data from triagonal matrizes
@
text
@d1 8
d15 1
a15 1
static char rcsid[] = "$Id: oldmat_getput.c,v 1.5 1992/03/31 02:05:47 se Exp $";
d18 3
@


1.5
log
@added casts to (int *) to calls of {get,put}{le,he}{4,8}()
@
text
@d1 2
d7 1
a7 1
static char rcsid[] = "$Id: oldmat_getput.c,v 1.4 1992/02/17 23:15:32 se Exp $";
d10 3
d27 4
d93 166
@


1.4
log
@added functions to read low and high endian 8 byte float matrixes
@
text
@d5 1
a5 1
static char rcsid[] = "$Id: oldmat_getput.c,v 1.3 1992/02/14 19:05:34 se Exp $";
d8 3
d93 1
a93 1
  return getle4 (mat->fd, buffer, fpos (4), num);
d101 1
a101 1
  return putle4 (mat->fd, buffer, fpos (4), num);
d109 1
a109 1
  return gethe4 (mat->fd, buffer, fpos (4), num);
d117 1
a117 1
  return puthe4 (mat->fd, buffer, fpos (4), num);
d127 1
a127 1
  return getle8 (mat->fd, buffer, fpos (4), num);
d135 1
a135 1
  return putle8 (mat->fd, buffer, fpos (4), num);
d143 1
a143 1
  return gethe8 (mat->fd, buffer, fpos (4), num);
d151 1
a151 1
  return puthe8 (mat->fd, buffer, fpos (4), num);
@


1.3
log
@first implementation of (trivial) floating point spectra and matrices
@
text
@d5 1
a5 1
static char rcsid[] = "$Id: oldmat_getput.c,v 1.2 1992/02/13 14:37:45 se Exp $";
d8 3
d115 34
@


1.2
log
@added rcsid[]
@
text
@d5 1
a5 1
static char rcsid[] = "$Id$";
d7 4
a10 1
/* $Log$
d78 34
@


1.1
log
@Initial revision
@
text
@d5 6
@
