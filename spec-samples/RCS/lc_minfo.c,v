head	1.13;
access;
symbols;
locks;
comment	@ * @;


1.13
date	93.07.20.17.56.36;	author se;	state Exp;
branches;
next	1.12;

1.12
date	92.07.30.12.09.41;	author se;	state Exp;
branches;
next	1.11;

1.11
date	92.07.08.21.03.39;	author se;	state Exp;
branches;
next	1.10;

1.10
date	92.07.08.18.44.34;	author se;	state Exp;
branches;
next	1.9;

1.9
date	92.06.30.14.49.04;	author se;	state Exp;
branches;
next	1.8;

1.8
date	92.06.10.11.13.34;	author se;	state Exp;
branches;
next	1.7;

1.7
date	92.05.13.23.32.12;	author se;	state Exp;
branches;
next	1.6;

1.6
date	92.03.31.01.59.46;	author se;	state Exp;
branches;
next	1.5;

1.5
date	92.03.17.15.20.46;	author se;	state Exp;
branches;
next	1.4;

1.4
date	92.02.19.19.16.53;	author se;	state Exp;
branches;
next	1.3;

1.3
date	92.02.18.23.28.59;	author se;	state Exp;
branches;
next	1.2;

1.2
date	92.02.13.14.37.45;	author se;	state Exp;
branches;
next	1.1;

1.1
date	92.02.03.17.38.25;	author se;	state Exp;
branches;
next	;


desc
@subroutines to interpret the file headers of line compressed matrix files
on open and update the headers on close
@


1.13
log
@modified for use with access method module
@
text
@/*
 * lc_minfo.c:		Copyright 1992 by 
 *			Stefan Esser
 *			Institut for Nuclear Physics
 *			xUniversity of Cologne, Germany
 *
 */

#include <stdlib.h>
#include <memory.h>

#include "mfile.h"
#include "maccess.h"
#include "endian.h"
#include "getputint.h"
#include "lc_minfo.h"
#include "lc_getput.h"
#include "lc_c1.h"
#include "lc_c2.h"

static char rcsid[] = "$Id: lc_minfo.c,v 1.12 1992/07/30 12:09:41 se Exp $";

/* $Log: lc_minfo.c,v $
 * Revision 1.12  1992/07/30  12:09:41  se
 * added copyright note
 *
 * Revision 1.11  1992/07/08  21:03:39  se
 * general cleanup for strictest GCC warning levels
 *
 * Revision 1.10  1992/07/08  18:44:34  se
 * reestablished traditional function declarations for compatibility with
 * non ANSI compilers
 *
 * Revision 1.9  92/06/30  14:49:04  14:49:04  se (Stefan Esser)
 * removed references to lc3_compress etc.
 * 
 * Revision 1.8  1992/06/10  11:13:34  se
 * changes to reflect mat->specinfo now being union {int, int*}
 *
 * Revision 1.7  1992/05/13  23:32:12  se
 * *** empty log message ***
 *
 * Revision 1.6  1992/03/31  01:59:46  se
 * corrected calculation of lci->freepos
 * added check for file corruption due to wrong lci->freepos
 *
 * Revision 1.5  1992/03/17  15:20:46  se
 * complete rewrite to improve signalling of error conditions
 * init_lci now allocates heap space in the way required by free_lci
 * new subroutine lc_flush to allow flushing cashed data to disk
 *
 * Revision 1.4  1992/02/19  19:16:53  se
 * set MST_DIMSFIXED and MST_INITIALIZED in mat->status
 * check MST_INITIALIZED instead of MST_DIMSFIXED in init_lci()
 *
 * Revision 1.3  1992/02/18  23:28:59  se
 * init_lci simply returns if MST_DIMSFIXED already set
 *
 * Revision 1.2  1992/02/13  14:37:45  se
 * added rcsid[]
 *
 */


#if defined(__STDC__) || defined(__cplusplus)
# define P_(s) s
#else
# define P_(s) ()
#endif

static int init_lci P_((MFILE *mat, u_int freepos, u_int freelistpos, u_int poslentablepos));
/* static int lc_updateheader P_((MFILE *mat)); */
static void free_lci P_((MFILE *mat));
static int lc_flush P_((MFILE *mat));

#undef P_

static int init_lci(mat, freepos, freelistpos, poslentablepos)
     MFILE *mat;
     unsigned int freepos, freelistpos, poslentablepos;
{
  u_int n = mat->lines * mat->levels;

  lc_minfo *lci = (lc_minfo *)malloc (sizeof (lc_minfo));

  mat->specinfo.p = (void *)lci;

  if (lci) {
    lci->version		= mat->version;
    lci->cachedline		= -1;
    lci->cachedcomprline	= -1;
    lci->comprlinelen		= 0;
    lci->cachedlinedirty	= 0;
    lci->linebuf		= NULL;
    lci->comprlinebuf		= NULL;

    switch (lci->version) {

 case LC_C1_VERSION:
      lci->comprf	= lc1_compress;
      lci->uncomprf	= lc1_uncompress;
      lci->comprlinebuf	= (void *)malloc (lc1_comprlinelenmax (mat->columns));
      break;

 case LC_C2_VERSION:
      lci->comprf	= lc2_compress;
      lci->uncomprf	= lc2_uncompress;
      lci->comprlinebuf	= (void *)malloc (lc2_comprlinelenmax (mat->columns));
      break;

    }

    lci->linebuf	= (int *)malloc (mat->columns * sizeof(int));
    lci->poslentableptr	= (lc_poslen *)malloc (n * sizeof(lc_poslen));
  
    if (lci->poslentableptr && lci->linebuf && lci->comprlinebuf) {
  
      if (freepos != 0) {
	lci->poslentablepos	= poslentablepos;
        lci->freepos		= freepos;
	lci->freelistpos	= freelistpos;
        if (getle4 (mat->ap, (int *)lci->poslentableptr, 
		    poslentablepos, 2 * n) == 2 * n) {
	  lc_poslen lpc;
	  lpc.len = lci->poslentableptr[0].len;
	  lpc.pos = lci->poslentableptr[0].pos;
	  if (lpc.len && lpc.pos < sizeof (lc_header) + n * sizeof(lc_poslen))
	    return -1;
	  return 0;
	}
      } else {
	lci->poslentablepos	= sizeof (lc_header);
        lci->freepos		= lci->poslentablepos + n * sizeof(lc_poslen);
	lci->freelistpos	= 0;
        memset (lci->poslentableptr, 0, n * sizeof(lc_poslen));
	return 0;
      }
    }
  }
  return -1;
}

void lc_probe (mat)
     MFILE *mat;
{
  lc_header lch;
  
  if (_get (mat->ap, &lch, 0, sizeof(lch)) != sizeof(lch))	return;

  if (lch.magic != GETLE4((unsigned)MAGIC_LC))				return;

  mat->status		|=MST_DIMSFIXED;
  mat->filetype		= MAT_LC;
  mat->version		= GETLE4(lch.version);

  mat->levels		= GETLE4(lch.levels);
  mat->lines		= GETLE4(lch.lines);
  mat->columns		= GETLE4(lch.columns);

  mat->mgeti4f		= lc_get;
  mat->mputi4f		= lc_put;
  mat->mflushf		= lc_flush;
  mat->muninitf		= lc_uninit;

  if (init_lci (mat, GETLE4(lch.freepos), 
			GETLE4(lch.freelistpos), 
			GETLE4(lch.poslentablepos)) != 0) free_lci (mat);
  if (mat->specinfo.p) mat->status |= (MST_INITIALIZED | MST_DIMSFIXED);
}

void lc_init (mat)
     MFILE *mat;
{
  if (mat->status & MST_INITIALIZED) return;

  if (mat->version == 0) {
    mat->version = LC_STD_VERSION;
  }

  if (init_lci (mat, 0, 0, 0) != 0) {
    free_lci (mat);
    mat->filetype = MAT_INVALID;
    return;
  }  

  mat->mgeti4f		= lc_get;
  mat->mputi4f		= lc_put;
  mat->mflushf		= lc_flush;
  mat->muninitf		= lc_uninit;
}


#ifdef undef
int lc_putinfo (mat, info)
     MFILE *mat;
     minfo* info;
{
  return 0;
}
#endif


int lc_uninit (mat)
     MFILE *mat;
{
  int status;

  status = lc_flush (mat);
  free_lci (mat);
  return status;
}  


static int lc_flush (mat)
     MFILE *mat;
{
  if (mat->status & MST_DIRTY) {
    lc_header lch;
    lc_minfo *lci = (lc_minfo *)mat->specinfo.p;
    unsigned int n;
  
    if (lc_flushcache (mat) !=0) return -1;

    lch.magic		= GETLE4((unsigned)MAGIC_LC);

    lch.levels		= GETLE4(mat->levels);
    lch.lines		= GETLE4(mat->lines);
    lch.columns		= GETLE4(mat->columns);

    lch.version		= GETLE4(lci->version);
    lch.poslentablepos	= GETLE4(lci->poslentablepos);
    lch.freepos		= GETLE4(lci->freepos);
    lch.freelistpos	= GETLE4(lci->freelistpos);
    lch.used		= 0;			/* not yet implemented */
    lch.free		= 0;
    lch.status		= 0;

    if (_put (mat->ap, &lch, 0, sizeof(lch)) != sizeof(lch)) return -1;

    n = mat->levels * mat->lines;
    if (putle4 (mat->ap, (int *)lci->poslentableptr, lci->poslentablepos, 2*n) != 2*n) return -1;
    if (_flush (mat->ap) != 0) return -1;
    mat->status &= ~MST_DIRTY;
  }
  return 0;
}


static void free_lci (mat)
     MFILE *mat;
{
  if (mat != NULL) {
    lc_minfo *lci = (lc_minfo *)mat->specinfo.p;
    if (lci->linebuf != NULL)		free (lci->linebuf);
    if (lci->comprlinebuf != NULL)	free (lci->comprlinebuf);
    if (lci->poslentableptr != NULL)	free (lci->poslentableptr);
    free (lci);
  }
  mat->filetype = MAT_INVALID;
}


@


1.12
log
@added copyright note
@
text
@d13 1
d21 1
a21 1
static char rcsid[] = "$Id: lc_minfo.c,v 1.11 1992/07/08 21:03:39 se Exp $";
d24 3
d122 1
a122 1
        if (getle4 (mat->fd, (int *)lci->poslentableptr, 
d148 1
a148 1
  if (get (mat->fd, &lch, 0, sizeof(lch)) != sizeof(lch))	return;
d150 1
a150 1
  if (lch.magic != GETLE4(MAGIC_LC))				return;
d224 1
a224 1
    lch.magic		= GETLE4(MAGIC_LC);
d238 1
a238 1
    if (put (mat->fd, &lch, 0, sizeof(lch)) != sizeof(lch)) return -1;
d241 2
a242 1
    if (putle4 (mat->fd, (int *)lci->poslentableptr, lci->poslentablepos, 2*n) != 2*n) return -1;
@


1.11
log
@general cleanup for strictest GCC warning levels
@
text
@d1 8
d20 1
a20 1
static char rcsid[] = "$Id: lc_minfo.c,v 1.10 1992/07/08 18:44:34 se Exp $";
d23 3
@


1.10
log
@reestablished traditional function declarations for compatibility with
non ANSI compilers
@
text
@d12 1
a12 1
static char rcsid[] = "$Id: lc_minfo.c,v 1.8 1992/06/10 11:13:34 se Exp $";
d14 5
a18 1
/* $Log:	lc_minfo.c,v $
d56 1
a56 1
static int init_lci P_((MFILE *mat, int freepos, int freelistpos, int poslentablepos));
d65 1
a65 1
     int freepos, freelistpos, poslentablepos;
d87 1
a87 1
      lci->comprlinebuf	= (u_int *)malloc (lc1_comprlinelenmax (mat->columns));
d93 1
a93 1
      lci->comprlinebuf	= (u_int *)malloc (lc2_comprlinelenmax (mat->columns));
d205 1
a205 1
    int n;
@


1.9
log
@removed references to lc3_compress etc.
@
text
@d14 4
a17 1
/* $Log: lc_minfo.c,v $
d46 6
d57 5
a61 1
static int init_lci(MFILE *mat, int freepos, int freelistpos, int poslentablepos)
d152 2
a153 1
void lc_init (MFILE *mat)
d175 3
a177 1
int lc_putinfo (MFILE *mat, minfo* info)
d184 2
a185 1
int lc_uninit (MFILE *mat)
d195 2
a196 1
static int lc_flush (MFILE *mat)
d229 2
a230 1
static void free_lci (MFILE *mat)
@


1.8
log
@changes to reflect mat->specinfo now being union {int, int*}
@
text
@a10 1
#include "lc_c3.h"
d12 1
a12 1
static char rcsid[] = "$Id: lc_minfo.c,v 1.7 1992/05/13 23:32:12 se Exp $";
d15 3
a78 5
 case LC_C3_VERSION:
      lci->comprf	= lc3_compress;
      lci->uncomprf	= lc3_uncompress;
      lci->comprlinebuf	= (u_int *)malloc (lc3_comprlinelenmax (mat->columns));
      break;
@


1.7
log
@*** empty log message ***
@
text
@d13 1
a13 1
static char rcsid[] = "$Id: lc_minfo.c,v 1.6 1992/03/31 01:59:46 se Exp $";
d16 3
d52 1
a52 1
  mat->specinfo	= (void *)lci;
d139 1
a139 1
  if (mat->specinfo) mat->status |= (MST_INITIALIZED | MST_DIMSFIXED);
d185 1
a185 1
    lc_minfo *lci = (lc_minfo *)mat->specinfo;
d217 1
a217 1
    lc_minfo *lci = (lc_minfo *)mat->specinfo;
@


1.6
log
@corrected calculation of lci->freepos
added check for file corruption due to wrong lci->freepos
@
text
@d13 1
a13 1
static char rcsid[] = "$Id: lc_minfo.c,v 1.5 1992/03/17 15:20:46 se Exp $";
d16 4
d92 3
a94 1
	  lc_poslen lpc = lci->poslentableptr[0];
@


1.5
log
@complete rewrite to improve signalling of error conditions
init_lci now allocates heap space in the way required by free_lci
new subroutine lc_flush to allow flushing cashed data to disk
@
text
@d2 1
a2 1
/* #include <memory.h>*/
d13 1
a13 1
static char rcsid[] = "$Id: lc_minfo.c,v 1.4 1992/02/19 19:16:53 se Exp $";
d16 5
d35 1
a35 1
static int lc_updateheader P_((MFILE *mat));
d87 6
a92 1
		    poslentablepos, 2 * n) == 2 * n) return 0;
d95 1
a95 1
        lci->freepos		= lci->poslentablepos + sizeof(lc_poslen);
@


1.4
log
@set MST_DIMSFIXED and MST_INITIALIZED in mat->status
check MST_INITIALIZED instead of MST_DIMSFIXED in init_lci()
@
text
@d13 1
a13 1
static char rcsid[] = "$Id: lc_minfo.c,v 1.3 1992/02/18 23:28:59 se Exp $";
d16 4
d32 1
d38 1
a38 2
  lc_poslen *ptr;
  lc_minfo *lci;
d40 1
a40 2
  if ((ptr = (lc_poslen *)malloc (n * sizeof(lc_poslen))) == NULL) return -1;
  if ((lci = (lc_minfo *)malloc (sizeof (lc_minfo)))	  == NULL) return -1;
d42 8
a49 1
  mat->specinfo		= (void *)lci;
d51 1
a51 16
  lci->version		= mat->version;
  lci->poslentableptr	= ptr;
  lci->cachedline	= -1;
  lci->cachedcomprline	= -1;
  lci->comprlinelen	= 0;
  lci->cachedlinedirty	= 0;

  if (freepos != 0) {
    lci->freepos	= freepos;
    lci->freelistpos	= freelistpos;
    lci->poslentablepos	= poslentablepos;
  } else {
    lci->freepos	= sizeof (lc_header);
    lci->poslentablepos	= 0;
    lci->freelistpos	= 0;
  }
a52 1
  switch (lci->version) {
d54 4
a57 4
    lci->comprf		= lc1_compress;
    lci->uncomprf	= lc1_uncompress;
    lci->comprlinebuf	= (u_int *)malloc (lc1_comprlinelenmax (mat->columns));
    break;
d60 4
a63 4
    lci->comprf		= lc2_compress;
    lci->uncomprf	= lc2_uncompress;
    lci->comprlinebuf	= (u_int *)malloc (lc2_comprlinelenmax (mat->columns));
    break;
d66 5
a70 4
    lci->comprf		= lc3_compress;
    lci->uncomprf	= lc3_uncompress;
    lci->comprlinebuf	= (u_int *)malloc (lc3_comprlinelenmax (mat->columns));
    break;
d72 2
a73 4
 default:
    return -1;
  }
  lci->linebuf = (int *)malloc (mat->columns * sizeof(int));
d75 1
a75 1
  if (lci->linebuf == NULL || lci->comprlinebuf == NULL) return -1;
d77 14
a90 6
  if (poslentablepos == 0) {
    memset (ptr, 0, n * sizeof(lc_poslen));
    lci->poslentablepos = lci->freepos;
    lci->freepos += n * sizeof(lc_poslen);
  } else {
    if (getle4 (mat->fd, (int *)ptr, poslentablepos, 2 * n) != 2 * n) return -1;
d92 1
a92 1
  return 0;
d114 1
d139 1
d144 1
d149 1
d154 3
a156 1
  lc_updateheader (mat);
d158 1
a158 1
  return 0;
d162 1
a162 1
static int lc_updateheader (MFILE *mat)
d169 1
a169 1
    lc_flush (mat);
d188 2
a189 5
    if (n = (putle4 (mat->fd, 
		     (int *)lci->poslentableptr, 
		     lci->poslentablepos, 
		     2*n) 
	     != 2*n))						return -1;
@


1.3
log
@init_lci simply returns if MST_DIMSFIXED already set
@
text
@d13 1
a13 1
static char rcsid[] = "$Id: lc_minfo.c,v 1.2 1992/02/13 14:37:45 se Exp $";
d16 3
d118 1
d123 1
a123 1
  if (mat->status & MST_DIMSFIXED) return;
@


1.2
log
@added rcsid[]
@
text
@d13 1
a13 1
static char rcsid[] = "$Id$";
d15 4
a18 1
/* $Log$
d119 2
@


1.1
log
@Initial revision
@
text
@d13 6
@
