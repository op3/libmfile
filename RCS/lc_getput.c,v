head	1.12;
access;
symbols;
locks;
comment	@ * @;


1.12
date	93.07.20.17.56.15;	author se;	state Exp;
branches;
next	1.11;

1.11
date	92.07.30.12.09.41;	author se;	state Exp;
branches;
next	1.10;

1.10
date	92.07.08.18.44.34;	author se;	state Exp;
branches;
next	1.9;

1.9
date	92.07.08.06.23.10;	author se;	state Exp;
branches;
next	1.8;

1.8
date	92.06.30.14.48.32;	author se;	state Exp;
branches;
next	1.7;

1.7
date	92.06.10.11.12.04;	author se;	state Exp;
branches;
next	1.6;

1.6
date	92.05.13.23.30.35;	author se;	state Exp;
branches;
next	1.5;

1.5
date	92.03.31.02.25.31;	author se;	state Exp;
branches;
next	1.4;

1.4
date	92.03.31.01.58.17;	author se;	state Exp;
branches;
next	1.3;

1.3
date	92.03.17.15.12.36;	author se;	state Exp;
branches;
next	1.2;

1.2
date	92.02.13.14.37.45;	author se;	state Exp;
branches;
next	1.1;

1.1
date	92.02.03.17.38.25;	author se;	state Exp;
branches;
next	;


desc
@read and write subroutines for line compressed matrix files
@


1.12
log
@modified for use with access method module
@
text
@/*
 * lc_getput.c:		Copyright 1992 by 
 *			Stefan Esser
 *			Institut for Nuclear Physics
 *			University of Cologne, Germany
 *
 */

#include <sys/types.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>
#include <errno.h>

#include "mfile.h"
#include "maccess.h"
#include "getputint.h"
#include "lc_minfo.h"
#include "lc_c1.h"
#include "lc_c2.h"
#include "lc_getput.h"

static char rcsid[] = "$Id: lc_getput.c,v 1.11 1992/07/30 12:09:41 se Exp $";

/* $Log: lc_getput.c,v $
 * Revision 1.11  1992/07/30  12:09:41  se
 * added copyright note
 *
 * Revision 1.10  1992/07/08  18:44:34  se
 * reestablished traditional function declarations for compatibility with
 * non ANSI compilers
 *
 * Revision 1.9  92/07/08  06:23:10  06:23:10  se (Stefan Esser)
 * prepended explicit cast to void* to 2nd parameter of get and put
 * 
 * Revision 1.8  1992/06/30  14:48:32  se
 * removed forced definition of VERIFY_COMPRESSION
 *
 * Revision 1.7  1992/06/10  11:12:04  se
 * changes to reflect mat->specinfo now being union {int, int*}
 *
 * Revision 1.6  1992/05/13  23:30:35  se
 * put back in the call to verifycompr() which was erroneously deleted
 * at the time of the last major changes
 *
 * Revision 1.5  1992/03/31  02:25:31  se
 * now includes stdio.h and memory.h
 *
 * Revision 1.4  1992/03/31  01:58:17  se
 * removed unneccessary definition of lc_alloc()
 *
 * Revision 1.3  1992/03/17  15:12:36  se
 * complete rewrite to allow detection and signalling of write errors
 * lc_flush renamed to lc_flushcache, now returns int
 * tryreadcomprline replaced by readline, returns int
 * trywritecomprline replaced by writeline, returns int
 * deleted flushcacheline
 *
 * Revision 1.2  1992/02/13  14:37:45  se
 * added rcsid[]
 *
 */

#if defined(__STDC__) || defined(__cplusplus)
# define P_(s) s
#else
# define P_(s) ()
#endif

/* static int lc_alloc P_((MFILE *mat, int n)); */
static int readline P_((MFILE *mat, int *buffer, u_int line));
static int writeline P_((MFILE *mat, int *buffer, u_int line));
static void trycacheline P_((MFILE *mat, u_int line));

#undef P_

#ifdef VERIFY_COMPRESSION
static void verifycompr (lci, line, num)
     lc_minfo *lci;
     int *line;
     int num;
{
  static int uncline[MAT_COLMAX];

  if (num > MAT_COLMAX) return;

  uncline[num-1] = line[num-1] -1;
  
  if ((lci->uncomprf (uncline, lci->comprlinebuf, num) != num) ||
      (memcmp (uncline, line, num * sizeof (int)) != 0)	) {
    u_int c;
    for (c = 0; c < num; c++) {
      if (uncline[c] != line[c]) {
        fprintf (stderr, "\ncompression error, aborting !!!\ncol = %d,  %d (correct %d)\n", c, uncline[c], line[c]);
	abort ();
      }
    }
  }
}
#endif /* VERIFY_COMPRESSION */

static int readline (mat, buffer, line)
     MFILE *mat;
     int *buffer;
     u_int line;
{
  lc_minfo *lci = (lc_minfo *) mat->specinfo.p;
  
  if (lci->cachedcomprline != line) {
    amp ap = mat->ap;
    lc_poslen *poslentable = lci->poslentableptr;

    u_int l		   = poslentable[line].len;
    u_int p		   = poslentable[line].pos;

    if (l == 0) return 0;

    if (_get (ap, (void *) lci->comprlinebuf, p, l) == l) {
      lci->comprlinelen	   = l;
      lci->cachedcomprline = line;
    }
  }
  if (lci->cachedcomprline == line) {
    return lci->uncomprf (buffer, lci->comprlinebuf, mat->columns);
  }
  return -1;
}

static int writeline (mat, buffer, line)
     MFILE *mat;
     int *buffer;
     u_int line;
{
  amp ap		  = mat->ap;
  lc_minfo *lci		  = (lc_minfo *) mat->specinfo.p;

  lc_poslen *poslentable  = lci->poslentableptr;

  u_int p		  = poslentable[line].pos;
  u_int l		  = poslentable[line].len;
  
  u_int fp		  = lci->freepos;
  u_int nl = lci->comprf (lci->comprlinebuf, buffer, mat->columns);
#ifdef VERIFY_COMPRESSION
  verifycompr (lci, buffer, mat->columns);
#endif
  if (nl > 0) {
    if (l + p == fp)	  { fp = p; l = 0; }
    if (l < nl)		  { l = nl; p = fp; fp += l; }

    if (_put (ap, (void *) lci->comprlinebuf, p, l) == l) {
      lci->freepos		= fp;
      poslentable[line].len	= l;
      poslentable[line].pos	= p;
      return mat->columns;
    }
  }
  return -1;
}

static void trycacheline (mat, line)
     MFILE *mat;
     u_int line;
{
  lc_minfo *lci = (lc_minfo *) mat->specinfo.p;
  
  if (lci->cachedline != line) {
    if (lci->cachedlinedirty
	&& writeline (mat, lci->linebuf, lci->cachedline) == mat->columns) {
      lci->cachedlinedirty = 0;
    }
    if (!lci->cachedlinedirty
	&& readline (mat, lci->linebuf, line) == mat->columns) {
      lci->cachedline = line;
    }
  }
}

int lc_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  lc_minfo *lci = (lc_minfo *) mat->specinfo.p;

  line += level * mat->lines;

  if (num != mat->columns) {
    trycacheline (mat, line);
  }

  if (line == lci->cachedline) {
    memcpy (buffer, lci->linebuf + col, num * sizeof (int));
    return num;
  }
  if (num == mat->columns) {
    return readline (mat, buffer, line);
  }

  return -1;
}

int lc_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  lc_minfo *lci = (lc_minfo *) mat->specinfo.p;

  line += level * mat->lines;

  if (num == mat->columns) {
    return writeline (mat, buffer, line);
  }
  if (lci->cachedline != line) {
    trycacheline (mat, line);
    if (lci->cachedline != line && !lci->cachedlinedirty) {
      memset (lci->linebuf, 0, mat->columns * sizeof (int));
      lci->cachedline = line;
    }
  }
  if (lci->cachedline == line) {
    lci->cachedlinedirty = 1;
    memcpy (lci->linebuf + col, buffer, num * sizeof (int));
    return num;
  }

  return -1;
}


int lc_flushcache (mat)
     MFILE *mat;
{
  lc_minfo *lci = (lc_minfo *) mat->specinfo.p;

  if (lci->cachedlinedirty
      && writeline (mat, lci->linebuf, lci->cachedline) != mat->columns) {
    return -1;
  }
  lci->cachedlinedirty = 0;
  return 0;
}



@


1.11
log
@added copyright note
@
text
@d17 1
d24 1
a24 1
static char rcsid[] = "$Id: lc_getput.c,v 1.10 1992/07/08 18:44:34 se Exp $";
d27 3
d111 1
a111 1
    int fd = mat->fd;
d119 1
a119 1
    if (get (fd, (void *) lci->comprlinebuf, p, l) == l) {
d135 1
a135 1
  int fd		  = mat->fd;
d152 1
a152 1
    if (put (fd, (void *) lci->comprlinebuf, p, l) == l) {
@


1.10
log
@reestablished traditional function declarations for compatibility with
non ANSI compilers
@
text
@d1 8
d23 1
a23 1
static char rcsid[] = "$Id: lc_getput.c,v 1.8 1992/06/30 14:48:32 se Exp $";
d25 5
a29 1
/* $Log:	lc_getput.c,v $
@


1.9
log
@prepended explicit cast to void* to 2nd parameter of get and put
@
text
@d17 4
a20 1
/* $Log: lc_getput.c,v $
d49 5
d60 1
d63 4
a66 1
static void verifycompr (lc_minfo *lci, int *line, int num)
d217 2
a218 1
int lc_flushcache (MFILE *mat)
@


1.8
log
@removed forced definition of VERIFY_COMPRESSION
@
text
@d15 1
a15 1
static char rcsid[] = "$Id: lc_getput.c,v 1.7 1992/06/10 11:12:04 se Exp $";
d18 3
d91 1
a91 1
    if (get (fd, lci->comprlinebuf, p, l) == l) {
d124 1
a124 1
    if (put (fd, lci->comprlinebuf, p, l) == l) {
@


1.7
log
@changes to reflect mat->specinfo now being union {int, int*}
@
text
@a0 3
#undef VERIFY_COMPRESSION
#define VERIFY_COMPRESSION

a12 1
#include "lc_c3.h"
d15 1
a15 1
static char rcsid[] = "$Id: lc_getput.c,v 1.6 1992/05/13 23:30:35 se Exp $";
d18 3
@


1.6
log
@put back in the call to verifycompr() which was erroneously deleted
at the time of the last major changes
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: lc_getput.c,v 1.5 1992/03/31 02:25:31 se Exp $";
d22 4
d78 1
a78 1
  lc_minfo *lci = (lc_minfo *) mat->specinfo;
d106 1
a106 1
  lc_minfo *lci		  = (lc_minfo *) mat->specinfo;
d136 1
a136 1
  lc_minfo *lci = (lc_minfo *) mat->specinfo;
d155 1
a155 1
  lc_minfo *lci = (lc_minfo *) mat->specinfo;
d179 1
a179 1
  lc_minfo *lci = (lc_minfo *) mat->specinfo;
d205 1
a205 1
  lc_minfo *lci = (lc_minfo *) mat->specinfo;
@


1.5
log
@now includes stdio.h and memory.h
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: lc_getput.c,v 1.4 1992/03/31 01:58:17 se Exp $";
d22 3
d111 3
a113 1

@


1.4
log
@removed unneccessary definition of lc_alloc()
@
text
@d7 2
d10 1
d19 1
a19 1
static char rcsid[] = "$Id: lc_getput.c,v 1.3 1992/03/17 15:12:36 se Exp $";
d22 3
@


1.3
log
@complete rewrite to allow detection and signalling of write errors
lc_flush renamed to lc_flushcache, now returns int
tryreadcomprline replaced by readline, returns int
trywritecomprline replaced by writeline, returns int
deleted flushcacheline
@
text
@d1 3
d16 1
a16 1
static char rcsid[] = "$Id: lc_getput.c,v 1.2 1992/02/13 14:37:45 se Exp $";
d19 7
d32 1
a32 1
static int lc_alloc P_((MFILE *mat, int n));
a36 2

#define VERIFY_COMPRESSION
@


1.2
log
@added rcsid[]
@
text
@d10 1
d13 1
a13 1
static char rcsid[] = "$Id$";
d15 4
a18 1
/* $Log$
d23 2
a24 3
static void tryreadcomprline P_((MFILE *mat, u_int line));
static void writecomprline P_((MFILE *mat));
static void flushcacheline P_((MFILE *mat));
d28 1
a28 1
/* #define VERIFY_COMPRESSION */
d30 23
a52 1
static void tryreadcomprline (mat, line)
d54 1
d66 3
a68 1
    if (l && get (fd, lci->comprlinebuf, p, l) == l) {
d73 4
d79 1
a79 1
static void writecomprline (mat)
d81 2
a87 3
  int line		  = lci->cachedcomprline;
  u_int nl		  = (lci->comprlinelen +3) & -4;
  u_int fp		  = lci->freepos;
d89 1
a90 1
  u_int p		  = poslentable[line].pos;
d92 2
a93 16
  if (l + p == fp)	  { fp = p; l = 0; }
  if (l < nl)		  { l = nl; p = fp; fp += l; }

  if (l && put (fd, lci->comprlinebuf, p, l) == l) {
    lci->freepos	  = fp;
    poslentable[line].len = l;
    poslentable[line].pos = p;
  }
}

#ifdef VERIFY_COMPRESSION
void verifycompr (lc_minfo *lci, int *line, int num)
{
  static int uncline[MAT_COLMAX];

  if (num > MAT_COLMAX) return;
d95 9
a103 10
  uncline[num-1] = line[num-1] -1;
  
  lci->uncomprf (uncline, lci->comprlinebuf, num);
  if (memcmp (uncline, line, num * sizeof (int)) != 0) {
    u_int c;
    for (c = 0; c < num; c++) {
      if (uncline[c] != line[c]) {
        fprintf (stderr, "\ncompression error, aborting !!!\ncol = %d,  %d (correct %d)\n", c, uncline[c], line[c]);
	abort ();
      }
d106 1
a106 17
}
#endif /* VERIFY_COMPRESSION */

static void flushcacheline (mat)
     MFILE *mat;
{
  lc_minfo *lci = (lc_minfo *) mat->specinfo;
  
  if (lci->cachedlinedirty) {
    lci->comprlinelen =
      lci->comprf (lci->comprlinebuf, lci->linebuf, mat->columns);
#ifdef VERIFY_COMPRESSION
    verifycompr (lci, lci->linebuf, mat->columns);
#endif /* VERIFY_COMPRESSION */
    writecomprline (mat);
    lci->cachedlinedirty = 0;
  }
d116 6
a121 4
    flushcacheline (mat);
    tryreadcomprline (mat, line);
    if (lci->cachedcomprline == line) {
      lci->uncomprf (lci->linebuf, lci->comprlinebuf, mat->columns);
d139 1
d145 1
a145 5
    tryreadcomprline (mat, line);
    if (line == lci->cachedcomprline) {
      lci->uncomprf (buffer, lci->comprlinebuf, num);
      return num;
    }
d147 2
a148 1
  return 0;
d161 1
a161 8
    lci->comprlinelen =
      lci->comprf (lci->comprlinebuf, buffer, mat->columns);
#ifdef VERIFY_COMPRESSION
    verifycompr (lci, buffer, mat->columns);
#endif /* VERIFY_COMPRESSION */
    lci->cachedcomprline = line;
    writecomprline (mat);
    return num;
d164 4
a167 7
    if (num == mat->columns) {
      flushcacheline (mat);
    } else {
      trycacheline (mat, line);
      if (lci->cachedline != line) {
        memset (lci->linebuf, 0, mat->columns * sizeof (int));
      }
d170 7
a176 4
  memcpy (lci->linebuf + col, buffer, num * sizeof (int));
  lci->cachedline = line;
  lci->cachedlinedirty = 1;
  return num;
d180 1
a180 1
void lc_flush (MFILE *mat)
d182 8
a189 1
  flushcacheline (mat);
@


1.1
log
@Initial revision
@
text
@d12 5
@
