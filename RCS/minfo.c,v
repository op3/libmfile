head	1.11;
access;
symbols;
locks
	root:1.11;
comment	@ * @;


1.11
date	93.01.20.13.03.44;	author se;	state Exp;
branches;
next	1.10;

1.10
date	92.07.30.12.09.41;	author se;	state Exp;
branches;
next	1.9;

1.9
date	92.07.08.18.44.34;	author se;	state Exp;
branches;
next	1.8;

1.8
date	92.07.08.06.25.35;	author se;	state Exp;
branches;
next	1.7;

1.7
date	92.06.10.11.15.17;	author se;	state Exp;
branches;
next	1.6;

1.6
date	92.05.13.23.35.28;	author se;	state Exp;
branches;
next	1.5;

1.5
date	92.03.31.02.03.07;	author se;	state Exp;
branches;
next	1.4;

1.4
date	92.02.18.23.32.04;	author se;	state Exp;
branches;
next	1.3;

1.3
date	92.02.15.17.22.42;	author se;	state Exp;
branches;
next	1.2;

1.2
date	92.02.13.14.37.45;	author se;	state Exp;
branches;
next	1.1;

1.1
date	92.02.03.17.38.25;	author se;	state Exp;
branches;
next	;


desc
@get or set matrix specific information in binary or text form
@


1.11
log
@mtxttoinfo now always sets version if filetype specified
@
text
@/*
 * minfo.c:		Copyright 1992 by 
 *			Stefan Esser
 *			Institut for Nuclear Physics
 *			University of Cologne, Germany
 *
 */

#include <ctype.h>
#include <stddef.h>
#include <memory.h>

#include "mfile.h"
#include "mat_types.h"

static char rcsid[] = "$Id: minfo.c,v 1.10 1992/07/30 12:09:41 se Exp $";

/* $Log: minfo.c,v $
 * Revision 1.10  1992/07/30  12:09:41  se
 * added copyright note
 * added support for comment field
 *
 * Revision 1.9  1992/07/08  18:44:34  se
 * reestablished traditional function declarations for compatibility with
 * non ANSI compilers
 *
 * Revision 1.8  92/07/08  06:25:35  06:25:35  se (Stefan Esser)
 * now includes stddef.h
 * 
 * Revision 1.7  1992/06/10  11:15:17  se
 * corrected test for compatible formats in msetinfo (|| changed to &&)
 *
 * Revision 1.6  1992/05/13  23:35:28  se
 * changed format string parser to accept no spaces within format strings,
 * but to accept a format string which contains any text after a valid
 * format string, if ithe two are seperated by white space
 *
 * Revision 1.5  1992/03/31  02:03:07  se
 * msetfmt now returns 0 if called with fmt==NULL
 *
 * Revision 1.4  1992/02/18  23:32:04  se
 * uses access functions instead of directly accessing the configuration
 * array matproc[].
 *
 * Revision 1.3  1992/02/15  17:22:42  se
 * *** empty log message ***
 *
 * Revision 1.2  1992/02/13  14:37:45  se
 * added rcsid[]
 *
 */

#if defined(__STDC__) || defined(__cplusplus)
# define P_(s) s
#else
# define P_(s) ()
#endif

static char *putnum P_((char *p, u_int n, int put1));
static char *putfmt P_((char *p, int filetype));
static char *minfototxt P_((char *fmt, minfo *info));

#undef P_

int mgetinfo (mat, info)
     MFILE *mat;
     minfo *info;
{
  if (info == NULL) return -1;

  if (mat == NULL) {
    info->filetype = MAT_INVALID;
    info->version  = 0;
    info->levels   = 0;
    info->lines    = 0;
    info->columns  = 0;
    info->status   = 0;
    info->name     = NULL;
    info->comment  = NULL;
    return -1;
  }

  info->filetype = mat->filetype;
  info->version	 = mat->version;
  info->levels	 = mat->levels;
  info->lines	 = mat->lines;
  info->columns	 = mat->columns;
  info->status   = mat->status;
  info->name     = mat->name;
  info->comment  = mat->comment;

  return 0;
}


int msetinfo (mat, info)
     MFILE *mat;
     minfo *info;
{
  /* check parameters and set filetype = MATINVALID in case of error */
  /* should call 'mat->msetinfof()' for sanity checks ... */

  if (mat == NULL || info == NULL)		return -1;

  if (mat->status & MST_DIMSFIXED) {
    if (mat->filetype	== info->filetype && 
	mat->version	== info->version  &&
	mat->levels	== info->levels	  &&
	mat->lines	== info->lines	  &&
	mat->columns	== info->columns) {
      return 0;
    } else {
      return -1;
    }
  }
  
  mat->filetype	= info->filetype;
  mat->version	= info->version;
  mat->levels	= info->levels;
  mat->lines	= info->lines;
  mat->columns	= info->columns;
  mat->status	= (mat->status & MST_INTERN) | (info->status & MST_USER);

  return 0;
}


int mtxttoinfo (fmt, info)
     char *fmt;
     minfo *info;
{
  int lev=0;
  int lin=0;
  int col=0;
  int typ=MAT_UNKNOWN;
  int ver=0;

#define skipspace(p)	while (isspace(*p)) (p++)
#define getnum(p,n)	while (isdigit(*p)) n=n*10 + ((*p++) - '0')

  if (fmt == NULL) return 0;
  if (info == NULL) return -1;

  skipspace (fmt);

  while (isdigit (*fmt)) {
    if (lev != 0) return -1;
    lev = lin;
    lin = col;

    col = 0;
    getnum (fmt, col);
    if (*fmt == 'k') { 
      fmt++;
      col *= 1024; 
    }      
    if (col == 0) return -1;

    if (*fmt == '.') {
      fmt++;
    } else {
      break;
    }
  }
  if (isalpha (*fmt)) {
    char fmtname[8];
    char c;
    int i=0;
    
    while (i < (sizeof (fmtname) -1) && (c = *fmt) && c != ':') {
      fmtname[i] = c;
      fmt++;
      i++;
    }
    fmtname[i] = '\0';

    typ = matproc_filetype (fmtname);
    if (typ == MAT_INVALID) return -1;

    if (*fmt == ':') {
      fmt++;
      getnum (fmt, ver);
    }
  }
  if (*fmt != '\0'&& !isspace (*fmt)) return -1;

  if (typ != MAT_UNKNOWN) {
    info->filetype = typ;
    info->version = ver;
  }

/*  if (info->filetype == MAT_UNKNOWN) info->filetype == MAT_STD; */

  if (col != 0) {
    info->levels  = lev ? lev : 1;
    info->lines   = lin ? lin : 1;
    info->columns = col ? col : 1;
  }
  return 0;
#undef skipspace
#undef getnum
}



static char *putnum (p, n, put1)
     char *p;
     u_int n;
     int put1;
{
  if (n != 1 || put1) {
    char numbuf[32];
    char *revp = numbuf;
  
    if (n && (n % 1024 == 0)) { n /= 1024; *revp++ = 'k'; }

    while (n) { char d = n % 10; *revp++ = d + '0'; n /= 10; }

    while (revp != numbuf) { *p++ = *--revp; }
  }
  *p = '\0';
  return p;
}


static char *putfmt (p, filetype)
     char *p;
     int filetype;
{
  char *cp;

  cp = matproc_fmtname (filetype);
  while (*cp) *p++ = *cp++;
  *p = '\0';
  return p;
}


static char *minfototxt (fmt, info)
     char *fmt;
     minfo *info;
{
  static char txtbuf[127];
  char *p;

  if (fmt == NULL) fmt = txtbuf;
  p = fmt;

  if (info == NULL) {
    p = putfmt (p, MAT_INVALID);
  } else {
    p = putnum (p, info->levels, 0);
    if (p != fmt) *p++ = '.';
    p = putnum (p, info->lines, p != fmt);
    if (p != fmt) *p++ = '.';
    p = putnum (p, info->columns, 1);
    if (p != fmt) *p++ = '.';

    p = putfmt (p, info->filetype);

    if (info->version) {
      *p++ = ':';
      p = putnum (p, info->version, 1);
    }
  }
  
  return fmt;
}


int msetfmt (mat, format)
     MFILE *mat;
     char *format;
{
  minfo info;
  if (mat && format) {
    if (mgetinfo (mat, &info) != 0) return -1;
    if (mtxttoinfo (format, &info) != 0) return -1;
    return msetinfo (mat, &info);
  } else {
    memset (&info, 0, sizeof (minfo));
    return mtxttoinfo (format, &info);
  }
}


char* mgetfmt (mat, format)
     MFILE *mat;
     char *format;
{
  minfo info;

  mgetinfo (mat, &info);
  return minfototxt (format, &info);
}
@


1.10
log
@added copyright note
added support for comment field
@
text
@d16 1
a16 1
static char rcsid[] = "$Id: minfo.c,v 1.9 1992/07/08 18:44:34 se Exp $";
d19 4
d187 5
a191 1
  if (typ != MAT_UNKNOWN) info->filetype = typ;
a198 1
  if (ver != 0) info->version = ver;
@


1.9
log
@reestablished traditional function declarations for compatibility with
non ANSI compilers
@
text
@d1 8
d16 1
a16 1
static char rcsid[] = "$Id: minfo.c,v 1.7 1992/06/10 11:15:17 se Exp $";
d18 5
a22 1
/* $Log:	minfo.c,v $
d74 2
d85 2
@


1.8
log
@now includes stddef.h
@
text
@d10 4
a13 1
/* $Log: minfo.c,v $
d37 9
d47 2
d108 3
a110 1
int mtxttoinfo (char *fmt, minfo *info)
d183 4
a186 1
static char *putnum (char *p, u_int n, int put1)
d203 3
a205 1
static char *putfmt (char *p, int filetype)
d216 3
a218 1
static char *minfototxt (char *fmt, minfo *info)
d248 3
a250 1
int msetfmt (MFILE *mat, char *format)
d264 3
a266 1
char* mgetfmt (MFILE *mat, char *format)
@


1.7
log
@corrected test for compatible formats in msetinfo (|| changed to &&)
@
text
@d2 1
d8 1
a8 1
static char rcsid[] = "$Id: minfo.c,v 1.6 1992/05/13 23:35:28 se Exp $";
d11 3
@


1.6
log
@changed format string parser to accept no spaces within format strings,
but to accept a format string which contains any text after a valid
format string, if ithe two are seperated by white space
@
text
@d7 1
a7 1
static char rcsid[] = "$Id: minfo.c,v 1.5 1992/03/31 02:03:07 se Exp $";
d10 5
d68 4
a71 4
    if (mat->filetype	== info->filetype || 
	mat->version	== info->version  ||
	mat->levels	== info->levels	  ||
	mat->lines	== info->lines	  ||
@


1.5
log
@msetfmt now returns 0 if called with fmt==NULL
@
text
@d7 1
a7 1
static char rcsid[] = "$Id: minfo.c,v 1.4 1992/02/18 23:32:04 se Exp $";
d10 3
a113 1
    skipspace(fmt);
a115 1
      skipspace (fmt);
d117 1
a117 1
      if (*fmt != '\0') return -1;
a138 1
    skipspace (fmt);
d140 1
a140 1
  if (*fmt != '\0') return -1;
@


1.4
log
@uses access functions instead of directly accessing the configuration
array matproc[].
@
text
@d2 1
d7 1
a7 1
static char rcsid[] = "$Id: minfo.c,v 1.3 1992/02/15 17:22:42 se Exp $";
d10 4
d76 1
a76 1
  mat->status	= mat->status & MST_INTERN | info->status & MST_USER;
d93 2
a94 1
  if (fmt == NULL || info == NULL) return -1;
@


1.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
static char rcsid[] = "$Id: minfo.c,v 1.2 1992/02/13 14:37:45 se Exp $";
d9 3
d30 1
d39 1
d71 1
a71 4

#ifdef undef
  initspecinfo (mat);
#endif
d114 10
a123 1
    matprocs *p = matproc;
d125 1
a125 4
    while (p->filetype != MAT_INVALID 
	     && strncmp (p->fmtname, fmt, strlen(p->fmtname)) != 0) p++;
    typ = p->filetype;
    fmt += strlen (p->fmtname);
d127 1
d172 2
a173 4
  
  matprocs *mp = matproc;
  while (mp->filetype != filetype && mp->filetype != MAT_INVALID) mp++;
  cp = mp->fmtname;
@


1.2
log
@added rcsid[]
@
text
@d6 1
a6 1
static char rcsid[] = "$Id$";
d8 4
a11 1
/* $Log$
d128 1
a128 1
  if (info->filetype == MAT_UNKNOWN) info->filetype == MAT_STD;
d206 1
a206 1
  if (mat) {
@


1.1
log
@Initial revision
@
text
@d6 6
d72 1
a72 1
static int mtxttoinfo (char *fmt, minfo *info)
@
