head	1.5;
access;
symbols;
locks;
comment	@ * @;


1.5
date	93.07.20.18.00.20;	author se;	state Exp;
branches;
next	1.4;

1.4
date	92.07.30.12.09.41;	author se;	state Exp;
branches;
next	1.3;

1.3
date	92.07.08.18.44.34;	author se;	state Exp;
branches;
next	1.2;

1.2
date	92.06.10.11.22.04;	author se;	state Exp;
branches;
next	1.1;

1.1
date	92.05.13.23.39.40;	author se;	state Exp;
branches;
next	;


desc
@functions to read and write spectra and matrizes stored as ASCII text
@


1.5
log
@modified for use with access method module
@
text
@/*
 * txt_getput.c:	Copyright 1992 by 
 *			Stefan Esser
 *			Institut for Nuclear Physics
 *			University of Cologne, Germany
 *
 */

#include <stdlib.h>
#include "mfile.h"
#include "maccess.h"
#include "txt_minfo.h"
#include "txt_getput.h"

static char rcsid[] = "$Id: txt_getput.c,v 1.4 1992/07/30 12:09:41 se Exp $";

/* $Log: txt_getput.c,v $
 * Revision 1.4  1992/07/30  12:09:41  se
 * added copyright note
 *
 * Revision 1.3  1992/07/08  18:44:34  se
 * reestablished traditional function declarations for compatibility with
 * non ANSI compilers
 *
 * Revision 1.2  92/06/10  11:22:04  11:22:04  se (Stefan Esser)
 * changes to reflect mat->specinfo now being union {int, int*}
 * 
 * Revision 1.1  1992/05/13  23:39:40  se
 * Initial revision
 *
 */


int txt_get (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  double *dblp = (double *) mat->specinfo.p;

/*  if (dblp == NULL) return -1; */

  int idx = ((level * mat->lines) + line) * mat->columns + col;

  memcpy (buffer, dblp +idx, num * sizeof (double));
  return num;
}

int txt_put (mat, buffer, level, line, col, num)
     MFILE *mat;
     u_int level, line, col, num;
     int *buffer;
{
  double *dblp = (double *) mat->specinfo.p;

/*  if (dblp == NULL) return -1; */

  int idx = ((level * mat->lines) + line) * mat->columns + col;

  memcpy (dblp +idx, buffer, num * sizeof (double));
  return num;
}

int txt_flush (mat)
     MFILE *mat;
{
  if ((mat->status & MST_DIRTY) != 0) 
  {
    double *dblp = (double *) mat->specinfo.p;
    int maxnum = mat->levels * mat->lines * mat->columns;
    int i;
    /* PROVISORISCH !!! */
    FILE *outf = (FILE*) mat->ap->specinfo.p;

    if (mat->version == 1)
    {
      fprintf (outf, "%s%s\n", TXT_MAGIC, mgetfmt (mat, NULL));
    }
    for (i = 0; i < maxnum; i++) 
    {
      if (fprintf (outf, "%G\n", *dblp++) < 0) return -1;
    }
    if (fflush (outf) != 0) return -1;
    mat->status &= ~MST_DIRTY;
  }
  return 0;
}
@


1.4
log
@added copyright note
@
text
@d11 1
d15 1
a15 1
static char rcsid[] = "$Id: txt_getput.c,v 1.3 1992/07/08 18:44:34 se Exp $";
d18 3
d72 2
a73 1
    FILE *outf = fdopen (mat->fd, "w");
d83 1
a83 1
    if (fflush (outf) < 0) return -1;
@


1.3
log
@reestablished traditional function declarations for compatibility with
non ANSI compilers
@
text
@d1 8
d14 1
a14 1
static char rcsid[] = "$Id: txt_getput.c,v 1.1 1992/05/13 23:39:40 se Exp $";
d16 5
a20 1
/* $Log:	txt_getput.c,v $
@


1.2
log
@changes to reflect mat->specinfo now being union {int, int*}
@
text
@d8 4
a11 1
/* $Log: txt_getput.c,v $
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
static char rcsid[] = "$Id$";
d8 4
a11 1
/* $Log$
d20 1
a20 1
  double *dblp = (double *) mat->specinfo;
d35 1
a35 1
  double *dblp = (double *) mat->specinfo;
d50 1
a50 1
    double *dblp = (double *) mat->specinfo;
@
