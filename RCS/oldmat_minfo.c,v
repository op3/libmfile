head	1.14;
access;
symbols;
locks;
comment	@ * @;


1.14
date	93.07.20.17.58.49;	author se;	state Exp;
branches;
next	1.13;

1.13
date	93.04.22.15.26.28;	author se;	state Exp;
branches;
next	1.12;

1.12
date	92.07.30.12.09.41;	author se;	state Exp;
branches;
next	1.11;

1.11
date	92.07.25.14.18.10;	author se;	state Exp;
branches;
next	1.10;

1.10
date	92.07.08.21.03.39;	author se;	state Exp;
branches;
next	1.9;

1.9
date	92.07.08.18.44.34;	author se;	state Exp;
branches;
next	1.8;

1.8
date	92.07.08.06.26.05;	author se;	state Exp;
branches;
next	1.7;

1.7
date	92.06.10.11.30.35;	author se;	state Exp;
branches;
next	1.6;

1.6
date	92.06.10.11.19.17;	author se;	state Exp;
branches;
next	1.5;

1.5
date	92.03.31.02.06.39;	author se;	state Exp;
branches;
next	1.4;

1.4
date	92.02.17.23.19.06;	author se;	state Exp;
branches;
next	1.3;

1.3
date	92.02.14.19.13.26;	author se;	state Exp;
branches;
next	1.2;

1.2
date	92.02.13.14.37.45;	author se;	state Exp;
branches;
next	1.1;

1.1
date	92.02.03.17.38.25;	author se;	state Exp;
branches;
next	;


desc
@guess matrix characteristics of traditional matrix files, depending on 
heuristics
@


1.14
log
@modified for use with access method module
@
text
@/*
 * oldmat_minfo.c:	Copyright 1992 by 
 *			Stefan Esser
 *			Institut for Nuclear Physics
 *			University of Cologne, Germany
 *
 */

#include <sys/types.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#include "mfile.h"
#include "maccess.h"
#include "getputint.h"
#include "oldmat_minfo.h"
#include "oldmat_getput.h"
#include "mat_types.h"

static char rcsid[] = "$Id: oldmat_minfo.c,v 1.13 1993/04/22 15:26:28 se Exp $";

/* $Log: oldmat_minfo.c,v $
 * Revision 1.13  1993/04/22  15:26:28  se
 * Support added for SIGNED 2 byte integer data
 *
 * Revision 1.12  1992/07/30  12:09:41  se
 * added copyright note
 *
 * Revision 1.11  1992/07/25  14:18:10  se
 * now includes string.h instead of strings.h and stdlib.h instead of malloc.h
 * added code to identify triagonal matrizes
 *
 * Revision 1.10  1992/07/08  21:03:39  se
 * general cleanup for strictest GCC warning levels
 *
 * Revision 1.9  1992/07/08  18:44:34  se
 * reestablished traditional function declarations for compatibility with
 * non ANSI compilers
 *
 * Revision 1.8  1992/07/08  06:26:05  se
 * now #includes strings.h
 *
 * Revision 1.7  1992/06/10  11:30:35  se
 * moved definition of MAGIC_OLDMAT into this file
 *
 * Revision 1.6  1992/06/10  11:19:17  se
 * introduced version 2 with file format described in trailer, version 1
 * is traditional file format, default is v.1 for integer, v.2 for float data
 *
 * Revision 1.5  1992/03/31  02:06:39  se
 * now includes malloc.h
 *
 * Revision 1.4  1992/02/17  23:19:06  se
 * init code now handles 8 byte float
 *
 * Revision 1.3  1992/02/14  19:13:26  se
 * added initialisation code for floating point matrixes
 *
 * Revision 1.2  1992/02/13  14:37:45  se
 * added rcsid[]
 *
 */

#define TESTBUFSIZE	(4096*4)	/* must be a power of 2 */

#if defined(__STDC__) || defined(__cplusplus)
# define P_(s) s
#else
# define P_(s) ()
#endif

static void guessdatatype P_((MFILE *mat, u_int pos));
static void guesslinescols P_((MFILE *mat, u_int size));

#undef P_

char MAGIC_OLDMAT[] = "\nMatFmt: ";

static void guessdatatype (mat, pos)
     MFILE *mat;
     u_int pos;
{
  u_char buf[TESTBUFSIZE];
  int nread;
  int n1 = 0, n2 = 0, n3 = 0, n4 = 0;
  int lf4 = 0, lf8 = 0, hf4 = 0, hf8 = 0, vaxf = 0, vaxg = 0;
  
  u_int i, lim4, lim8;
  
  pos &= (-8);
  nread = _get (mat->ap, (char *)buf, pos, sizeof(buf));
  nread &= (-8);

  if (nread <= 0)						return;
  
  for (i = 0; i < nread; i += 4) {
    u_int tli,thi,tvax,e;

    n1 += buf[i];
    n2 += buf[i+1];
    n3 += buf[i+2];
    n4 += buf[i+3];
/* consider floating point number, if within 2^-3 to 2^20 */
#define GETEXP(_n,_bits) (((_n) & 0x7fff) >> (15 - (_bits)))
#define MINEXP (-3)
#define MAXEXP (20)
    tli  = (buf[i+3] << 8) + buf[i+2];
    thi  = (buf[i  ] << 8) + buf[i+1];
    tvax = (buf[i+1] << 8) + buf[i  ];

    e = GETEXP (tli, 8);
    if (127 + MINEXP < e && e < 127 + MAXEXP) lf4++;
    e = GETEXP (thi, 8);
    if (127 + MINEXP < e && e < 127 + MAXEXP) hf4++;
    e = GETEXP (tvax, 8);
    if (127 + MINEXP < e && e < 127 + MAXEXP) vaxf++;

    if (i & 4) {
      e = GETEXP (tli, 11);
      if (1023 + MINEXP < e && e < 1023 + MAXEXP) lf8++;
    } else {
      e = GETEXP (thi, 11);
      if (1023 + MINEXP < e && e < 1023 + MAXEXP) hf8++;
      e = GETEXP (tvax, 11);
      if (1023 + MINEXP < e && e < 1023 + MAXEXP) vaxg++;
    }
#undef GETEXP    
#undef MINEXP
#undef MAXEXP
  }

  lim4 = 3 * (nread >> 4);
  lim8 = lim4 >> 1;

  mat->filetype = 
    n1 > n4 << 3			/* looks like low endian ? */
    ? n3 > n2 << 3
      ? MAT_LE2
      : n1 > n4 << 12 && n2 >= n3 << 2
	? MAT_LE4
	: MAT_UNKNOWN
    : n4 > n1 << 3			/* looks like high endian ? */
      ? n2 > n3 << 3
	? MAT_HE2
	: n4 > n1 << 12 && n3 >= n2 << 2
	  ? MAT_HE4
	  : MAT_UNKNOWN
      : MAT_UNKNOWN;

  if (mat->filetype == MAT_UNKNOWN &&
      (lf4 > lim4) + (hf4 > lim4) + (vaxf > lim4) +
      (lf8 > lim8) + (hf8 > lim8) + (vaxg > lim8) == 1) {
    mat->filetype =
      lf4 > lim4
      ? MAT_LF4
      : hf4 > lim4
	? MAT_HF4
	: vaxf > lim4
	  ? MAT_VAXF
	  : lf8 > lim8
	    ? MAT_LF8
	    : hf8 > lim8
	      ? MAT_HF8
	      : vaxg > lim8
		? MAT_VAXG
		: MAT_UNKNOWN;
  }
}

static void guesslinescols (mat, size)
     MFILE *mat;
     u_int size;
{
  int filetype = mat->filetype;
  
  if (filetype != MAT_INVALID) {
    u_int elems, lines, columns;

    switch (filetype) {
  case MAT_LE2:
  case MAT_HE2:
      elems = size >> 1;
      break;
    
  case MAT_LE4:
  case MAT_HE4:
  case MAT_LF4:
  case MAT_HF4:
  case MAT_VAXF:      
      elems = size >> 2;
      break;

  case MAT_LF8:
  case MAT_HF8:
  case MAT_VAXG:      
      elems = size >> 3;
      break;

  default:
      elems = 0;
      break;
    }

    columns = 0;
    if (elems == 4096 *4096) {
      lines   = 4096;
      columns = 4096;
    } else {
      lines = 1;
      while (lines <= (2<<15)) {
        if (elems == ((lines * (lines+1)) >> 1)) {
          columns = lines;
	  switch (filetype) {
	case MAT_LE2: { mat->filetype = MAT_LE2T; break; }
	case MAT_LE4: { mat->filetype = MAT_LE4T; break; }
	case MAT_HE2: { mat->filetype = MAT_HE2T; break; }
	case MAT_HE4: { mat->filetype = MAT_HE4T; break; }
	default:      { columns = 0;		  break; }
	  }
	  break;
	}
	lines <<= 1;
      }
      if (columns == 0) {
	lines   = 1;
	columns = elems;
      }
    }

    mat->lines      = lines;
    mat->columns    = columns;
    mat->version    = OLDMAT_STD_VERSION;
  }
}

static void checkformagic (mat, size)
     MFILE *mat;
     int   size;
{
  oldmat_header	omh;
  unsigned int s = sizeof (omh);
  unsigned int l = strlen (MAGIC_OLDMAT);

  if (size < s || _get (mat->ap, (char *) omh, size - s, s) != s) return;

  if (strncmp (omh, MAGIC_OLDMAT, l) != 0) return;
  msetfmt (mat, omh + l);
}

void oldmat_probe (mat)
     MFILE *mat;
{
  u_int size = mat->ap->size;

  checkformagic (mat, size);
  if (mat->filetype != MAT_UNKNOWN) return;

  guessdatatype (mat, (size /3) & -TESTBUFSIZE);
  if (mat->filetype == MAT_INVALID) return;

  guesslinescols (mat, size);
}

void oldmat_init (mat)
     MFILE *mat;
{
  if (0 < mat->columns && mat->columns <= MAT_COLMAX) {
    int filetype = mat->filetype;
    int datatype = matproc_datatype (filetype);
    int elemsize = datatype & MAT_D_SIZE;
    mgetf* getf  = matproc_getf (filetype);
    mputf* putf  = matproc_putf (filetype);
    
    mat->specinfo.i = elemsize;
    mat->version = OLDMAT_STD_VERSION;

    switch (datatype) {
  case MAT_D_I2U:
      mat->mgeti4f		= getf;
      mat->mputi4f		= putf;
      break;
  case MAT_D_I2S:
      mat->mgeti4f		= getf;
      mat->mputi4f		= putf;
      break;
  case MAT_D_I4S: 
      mat->mgeti4f		= getf;
      mat->mputi4f		= putf;
      break;
  case MAT_D_F4:
      mat->mgetf4f		= getf;
      mat->mputf4f		= putf;
      mat->version		= 2;
      break;
  case MAT_D_F8:
      mat->mgetf8f		= getf;
      mat->mputf8f		= putf;
      mat->version		= 2;
      break;
  default:
      return;
      break;
    }

    mat->muninitf		= oldmat_uninit;
  }
}

int oldmat_uninit (mat)
     MFILE *mat;
{
  if ((mat->status & MST_DIRTY) == 0) return 0;

  if (mat->version == 2)
  {
    oldmat_header omh;
    unsigned int elemsize = mat->specinfo.i;
    unsigned int matsize  = mat->levels * mat->lines * mat->columns * elemsize;

    if (matsize == 0) return 0;
    
    sprintf (omh, "%s%s\n", MAGIC_OLDMAT, mgetfmt (mat, NULL));

    if (_put (mat->ap, (char *) omh, matsize, sizeof (omh)) 
	!= sizeof (omh)) return -1;
  }
  return 0;
}

int oldmat_putinfo (mat, info)
     MFILE *mat;
     minfo *info;
{
  return 0;
}
@


1.13
log
@Support added for SIGNED 2 byte integer data
@
text
@a9 2
#include <sys/file.h>
#include <sys/stat.h>
d15 1
d21 1
a21 1
static char rcsid[] = "$Id: oldmat_minfo.c,v 1.12 1992/07/30 12:09:41 se Exp $";
d24 3
d92 1
a92 1
  nread = get (mat->fd, (char *)buf, pos, sizeof(buf));
d245 1
a245 1
  if (size < s || get (mat->fd, (char *) omh, size - s, s) != s) return;
d254 1
a254 8
  struct stat stat_buf;
  u_int size;
  
  if (fstat (mat->fd, &stat_buf) != 0) {
    mat->filetype = MAT_INVALID;
    return;
  }
  size = stat_buf.st_size;
d272 2
a273 2
    getf mgetf   = matproc_getf (filetype);
    putf mputf   = matproc_putf (filetype);
d280 2
a281 2
      mat->mgeti4f		= mgetf;
      mat->mputi4f		= mputf;
d284 2
a285 2
      mat->mgeti4f		= mgetf;
      mat->mputi4f		= mputf;
d288 2
a289 2
      mat->mgeti4f		= mgetf;
      mat->mputi4f		= mputf;
d292 2
a293 2
      mat->mgetf4f		= mgetf;
      mat->mputf4f		= mputf;
d297 2
a298 2
      mat->mgetf8f		= mgetf;
      mat->mputf8f		= mputf;
d325 1
a325 1
    if (put (mat->fd, (char *) omh, matsize, sizeof (omh)) 
@


1.12
log
@added copyright note
@
text
@d22 1
a22 1
static char rcsid[] = "$Id: oldmat_minfo.c,v 1.11 1992/07/25 14:18:10 se Exp $";
d25 3
d285 4
@


1.11
log
@now includes string.h instead of strings.h and stdlib.h instead of malloc.h
added code to identify triagonal matrizes
@
text
@d1 8
d22 1
a22 1
static char rcsid[] = "$Id: oldmat_minfo.c,v 1.10 1992/07/08 21:03:39 se Exp $";
d25 4
@


1.10
log
@general cleanup for strictest GCC warning levels
@
text
@d4 1
a4 1
#include <strings.h>
d6 1
a6 1
#include <malloc.h>
d14 1
a14 1
static char rcsid[] = "$Id: oldmat_minfo.c,v 1.9 1992/07/08 18:44:34 se Exp $";
d17 3
d188 1
d193 19
a211 2
      lines   = 1;
      columns = elems;
d266 1
a271 4



      mat->specinfo.i		= 2;
a275 1
      mat->specinfo.i		= 4;
a279 1
      mat->specinfo.i		= 4;
a284 1
      mat->specinfo.i		= 8;
a292 1
    if (mat->version == 0) mat->version = OLDMAT_STD_VERSION;
@


1.9
log
@reestablished traditional function declarations for compatibility with
non ANSI compilers
@
text
@d14 1
a14 1
static char rcsid[] = "$Id: oldmat_minfo.c,v 1.8 1992/07/08 06:26:05 se Exp $";
d17 4
d204 2
a205 2
  int s = sizeof (omh);
  int l = strlen (MAGIC_OLDMAT);
d207 1
a207 1
  if (get (mat->fd, (char *) omh, size - s, s) != s) return;
d216 1
a216 1
  struct stat stat;
d219 1
a219 1
  if (fstat (mat->fd, &stat) != 0) {
d223 1
a223 1
  size = stat.st_size;
d290 2
a291 2
    int elemsize = mat->specinfo.i;
    int matsize  = mat->levels * mat->lines * mat->columns * elemsize;
@


1.8
log
@now #includes strings.h
@
text
@d14 1
a14 1
static char rcsid[] = "$Id: oldmat_minfo.c,v 1.7 1992/06/10 11:30:35 se Exp $";
d17 3
d43 6
d52 2
d230 2
a231 1
void oldmat_init (MFILE *mat)
d278 2
a279 1
int oldmat_uninit (MFILE *mat)
d299 3
a301 1
int oldmat_putinfo (MFILE *mat, minfo *info)
@


1.7
log
@moved definition of MAGIC_OLDMAT into this file
@
text
@d4 1
d14 1
a14 1
static char rcsid[] = "$Id: oldmat_minfo.c,v 1.6 1992/06/10 11:19:17 se Exp $";
d17 3
@


1.6
log
@introduced version 2 with file format described in trailer, version 1
is traditional file format, default is v.1 for integer, v.2 for float data
@
text
@d13 1
a13 1
static char rcsid[] = "$Id: oldmat_minfo.c,v 1.5 1992/03/31 02:06:39 se Exp $";
d16 4
a33 1

d38 2
@


1.5
log
@now includes malloc.h
@
text
@d11 1
d13 1
a13 1
static char rcsid[] = "$Id: oldmat_minfo.c,v 1.4 1992/02/17 23:19:06 se Exp $";
d16 3
d36 1
a36 1
static void guessdatatype (mat, pos) 
d169 3
a171 2
    mat->lines    = lines;
    mat->columns  = columns;
d175 14
d200 4
d206 1
d212 15
a226 4
  if (mat->specinfo) {
    free (mat->specinfo);
    mat->specinfo		= NULL;
  }
d228 1
a228 6
  if (0 < mat->columns && mat->columns <= MAT_COLMAX) {
  
    switch (mat->filetype) {
  case MAT_LE2:
      mat->mgeti4f		= le2_get;
      mat->mputi4f		= le2_put;
d230 4
a233 19
  case MAT_HE2:
      mat->mgeti4f		= he2_get;
      mat->mputi4f		= he2_put;
      break;
  case MAT_LE4:
      mat->mgeti4f		= le4_get;
      mat->mputi4f		= le4_put;
      break;
  case MAT_HE4:
      mat->mgeti4f		= he4_get;
      mat->mputi4f		= he4_put;
      break;
  case MAT_LF4:
      mat->mgetf4f		= lf4_get;
      mat->mputf4f		= lf4_put;
      break;
  case MAT_HF4:
      mat->mgetf4f		= hf4_get;
      mat->mputf4f		= hf4_put;
d235 5
a239 4
#ifdef VAXF
  case MAT_VAXF:
      mat->mgetf4f		= vaxf_get;
      mat->mputf4f		= vaxf_put;
d241 5
a245 8
#endif
  case MAT_LF8:
      mat->mgetf8f		= lf8_get;
      mat->mputf8f		= lf8_put;
      break;
  case MAT_HF8:
      mat->mgetf8f		= hf8_get;
      mat->mputf8f		= hf8_put;
a246 6
#ifdef VAXG
  case MAT_VAXG:
      mat->mgetf8f		= vaxg_get;
      mat->mputf8f		= vaxg_put;
      break;
#endif
d253 1
d259 15
@


1.4
log
@init code now handles 8 byte float
@
text
@d5 1
d12 1
a12 1
static char rcsid[] = "$Id: oldmat_minfo.c,v 1.3 1992/02/14 19:13:26 se Exp $";
d15 3
@


1.3
log
@added initialisation code for floating point matrixes
@
text
@d11 1
a11 1
static char rcsid[] = "$Id: oldmat_minfo.c,v 1.2 1992/02/13 14:37:45 se Exp $";
d14 3
d216 20
@


1.2
log
@added rcsid[]
@
text
@d11 1
a11 1
static char rcsid[] = "$Id$";
d13 4
a16 1
/* $Log$
d193 4
a200 4
  case MAT_HE2:
      mat->mgeti4f		= he2_get;
      mat->mputi4f		= he2_put;
      break;
d204 8
@


1.1
log
@Initial revision
@
text
@d11 6
@
