head	1.9;
access;
symbols;
locks;
comment	@ * @;


1.9
date	93.07.20.17.55.46;	author se;	state Exp;
branches;
next	1.8;

1.8
date	92.07.30.12.09.41;	author se;	state Exp;
branches;
next	1.7;

1.7
date	92.07.08.18.44.34;	author se;	state Exp;
branches;
next	1.6;

1.6
date	92.07.08.06.21.53;	author se;	state Exp;
branches;
next	1.5;

1.5
date	92.05.13.23.28.17;	author se;	state Exp;
branches;
next	1.4;

1.4
date	92.03.31.01.55.01;	author se;	state Exp;
branches;
next	1.3;

1.3
date	92.02.15.17.22.42;	author se;	state Exp;
branches;
next	1.2;

1.2
date	92.02.13.14.37.45;	author se;	state Exp;
branches;
next	1.1;

1.1
date	92.02.03.17.38.25;	author se;	state Exp;
branches;
next	;


desc
@read and write files of 2 byte and 4 byte, high and low endian 
integer data
@


1.9
log
@modified for use with access method functions
@
text
@/*
 * getputint.c:		Copyright 1992 by 
 *			Stefan Esser
 *			Institut for Nuclear Physics
 *			University of Cologne, Germany
 *
 */

#include "mfile.h"
#include "endian.h"
#include "getputint.h"
#include "maccess.h"
#include <errno.h>

static char rcsid[] = "$Id: getputint.c,v 1.8 1992/07/30 12:09:41 se Exp $";

/* $Log: getputint.c,v $
 * Revision 1.8  1992/07/30  12:09:41  se
 * added copyright note
 *
 * Revision 1.7  1992/07/08  18:44:34  se
 * reestablished traditional function declarations for compatibility with
 * non ANSI compilers
 *
 * Revision 1.6  92/07/08  06:21:53  06:21:53  se (Stefan Esser)
 * changed 2nd parameter to get and put from char* to void* and introduced
 * local char *buffer for actual accesses
 * 
 * Revision 1.5  1992/05/13  23:28:17  se
 * changed type of parameter 'buffer' to get and put back to char *
 * because of compiler complaints about unknown size of *buffer
 *
 * Revision 1.4  1992/03/31  01:55:01  se
 * changed type of buffer from char* to void*
 *
 * Revision 1.3  1992/02/15  17:22:42  se
 * new functions for high and low endian 8 byte values {get,put}_{l,h}e8()
 *
 * Revision 1.2  1992/02/13  14:37:45  se
 * added rcsid[]
 *
 */

#ifdef undef
int get (fd, adr, pos, num)
     int fd;
     void *adr;
     u_int pos;
     u_int num;
{
  int w;
  int done = 0;
  char *buffer = adr;

  errno = 0;
  
  if (lseek (fd, pos, SEEK_SET) != pos) return -1;
    
  do {
    w = read(fd, buffer, num);
    if (w > 0){
      done	+= w;
      buffer	+= w;
      num	-= w;
    } else {
#ifndef OSK
      if (errno && errno != EINTR) {
#else
      if (errno) {
#endif
#ifdef undef
        int saveerrno = errno;
	(void) close(fd);
	errno = saveerrno;
	perror ("get");		/* ERROR ABORT */
	exit (1);		/* include corresponding header file !!! */
#endif
	return -1;
      } else {
        num =0;
      }
    }
  } while (num > 0);
  return done;
}


int put (fd, adr, pos, num)
     int fd;
     void *adr;
     u_int pos;
     u_int num;
{
  int w;
  int done = 0;
  char *buffer = adr;

  errno = 0;
  
  if (lseek (fd, pos, SEEK_SET) != pos) return -1;
    
  do {
    w = write(fd, buffer, num);
    if (w > 0){
      done	+= w;
      buffer	+= w;
      num	-= w;
    } else {
#ifndef OSK
      if (errno && errno != EINTR) {
#else
      if (errno) {
#endif
#ifdef undef
        int saveerrno = errno;
	(void) close(fd);
	errno = saveerrno;
	perror ("get");		/* ERROR ABORT */
	exit (1);		/* include corresponding header file !!! */
#endif
	return -1;
      } else {
        num =0;
      }
    }
  } while (num > 0);
  return done;
}
#endif /* undef */


u_int getle8 (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{     
#ifdef LOWENDIAN
  int *iobuf = buffer;
#else
  u_int iobuf[2*MAT_COLMAX], *p;
#endif

  u_int n = num << 3;
  if (_get (ap, (char *)iobuf, pos, n) != n) return 0;
#ifndef LOWENDIAN
  p = iobuf;
  for (n = num; n ; n--) {
    register int t1 = *(p++);
    register int t2 = *(p++);
    *(buffer++) = GETLE4(t2);
    *(buffer++) = GETLE4(t1);
  }
#endif
  return num;
}
     
u_int putle8 (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{
  u_int n;
#ifdef LOWENDIAN
  int *iobuf = buffer;
#else
  u_int iobuf[2*MAT_COLMAX], *p = iobuf;

  for (n = num; n ; n--) {
    register int t1 = *(buffer++);
    register int t2 = *(buffer++);
    *(p++) = GETLE4(t2);
    *(p++) = GETLE4(t1);
  }
#endif
  n = num << 3;
  if (_put (ap, (char *)iobuf, pos, n) != n) return 0;
  return num;
}

u_int gethe8 (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{     
#ifndef LOWENDIAN
  int *iobuf = buffer;
#else
  u_int iobuf[2*MAT_COLMAX], *p;
#endif

  u_int n = num << 3;
  if (_get (ap, (char *)iobuf, pos, n) != n) return 0;
#ifdef LOWENDIAN
  p = iobuf;
  for (n = num; n ; n--) {
    register int t1 = *(p++);
    register int t2 = *(p++);
    *(buffer++) = GETHE4(t2);
    *(buffer++) = GETHE4(t1);
  }
#endif
  return num;
}
     
u_int puthe8 (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{
  u_int n;
#ifndef LOWENDIAN
  int *iobuf = buffer;
#else
  u_int iobuf[2*MAT_COLMAX], *p = iobuf;

  for (n = num; n ; n--) {
    register int t1 = *(buffer++);
    register int t2 = *(buffer++);
    *(p++) = GETHE4(t2);
    *(p++) = GETHE4(t1);
  }
#endif
  n = num << 3;
  if (_put (ap, (char *)iobuf, pos, n) != n) return 0;
  return num;
}

u_int getle4 (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{     
#ifdef LOWENDIAN
  int *iobuf = buffer;
#else
  u_int iobuf[MAT_COLMAX], *p;
#endif

  u_int n = num << 2;
  if (_get (ap, (char *)iobuf, pos, n) != n) return 0;
#ifndef LOWENDIAN
  for (p = iobuf, n = num; n ; n--) {
    register int t = *(p++);
    *(buffer++) = GETLE4(t);
  }
#endif
  return num;
}
     
u_int putle4 (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{
  u_int n;
#ifdef LOWENDIAN
  int *iobuf = buffer;
#else
  u_int iobuf[MAT_COLMAX], *p;

  for (p = iobuf, n = num; n ; n--) {
    register int t = *(buffer++);
    *(p++) = GETLE4(t);
  }
#endif
  n = num << 2;
  if (_put (ap, (char *)iobuf, pos, n) != n) return 0;
  return num;
}

u_int gethe4 (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{
#ifndef LOWENDIAN
  int *iobuf = buffer;
#else
  u_int iobuf[MAT_COLMAX], *p;
#endif

  u_int n = num << 2;
  if (_get (ap, (char *)iobuf, pos, n) != n) return 0;
#ifdef LOWENDIAN
  for (p = iobuf, n = num; n ; n--) {
    register int t = *(p++);
    *(buffer++) = GETHE4(t);
  }
#endif
  return num;
}

u_int puthe4 (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{
  u_int n;
#ifndef LOWENDIAN
  int *iobuf = buffer;
#else
  u_int iobuf[MAT_COLMAX], *p;

  for (p = iobuf, n = num; n ; n--) {
    register int t = *(buffer++);
    *(p++) = GETHE4(t);
  }
#endif
  n = num << 2;
  if (_put (ap, (char *)iobuf, pos, n) != n) return 0;
  return num;
}

u_int getle2 (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{
  u_short iobuf[MAT_COLMAX], *p;
  u_int n = num << 1;

  if (_get (ap, (char *)iobuf, pos, n) != n) return 0;
  for (p = iobuf, n = num; n ; n--) {
    register int t = *(p++);
    *(buffer++) = (u_short) GETLE2(t);
  }
  return num;
}

u_int putle2 (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{
  u_short iobuf[MAT_COLMAX], *p;
  u_int n;

  for (p = iobuf, n = num; n ; n--) {
    register u_int t = *(buffer++);
    *(p++) = GETLE2(t);
  }
  n = num << 1;
  if (_put (ap, (char *)iobuf, pos, n) != n) return 0;
  return num;
}

u_int gethe2 (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{
  u_short iobuf[MAT_COLMAX], *p;
  u_int n = num << 1;

  if (_get (ap, (char *)iobuf, pos, n) != n) return 0;
  for (p = iobuf, n = num; n ; n--) {
    register int t = *(p++);
    *(buffer++) = (u_short) GETHE2(t);
  }
  return num;
}

u_int puthe2 (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{
  u_short iobuf[MAT_COLMAX], *p;
  u_int n;

  for (p = iobuf, n = num; n ; n--) {
    register u_int t = *(buffer++);
    *(p++) = GETHE2(t);
  }
  n = num << 1;
  if (_put (ap, (char *)iobuf, pos, n) != n) return 0;
  return num;
}

u_int getle2s (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{
  short iobuf[MAT_COLMAX], *p;
  u_int n = num << 1;

  if (_get (ap, (char *)iobuf, pos, n) != n) return 0;
  for (p = iobuf, n = num; n ; n--) {
    register int t = *(p++);
    *(buffer++) = (short) GETLE2(t);
  }
  return num;
}

u_int gethe2s (ap, buffer, pos, num)
     amp ap;
     u_int pos, num;
     int *buffer;
{
  u_short iobuf[MAT_COLMAX], *p;
  u_int n = num << 1;

  if (_get (ap, (char *)iobuf, pos, n) != n) return 0;
  for (p = iobuf, n = num; n ; n--) {
    register int t = *(p++);
    *(buffer++) = (short) GETHE2(t);
  }
  return num;
}

@


1.8
log
@added copyright note
@
text
@d12 1
d15 1
a15 1
static char rcsid[] = "$Id: getputint.c,v 1.7 1992/07/08 18:44:34 se Exp $";
d18 3
d44 1
a44 1

d129 1
d132 2
a133 2
u_int getle8 (fd, buffer, pos, num)
     int fd;
d144 1
a144 1
  if (get (fd, (char *)iobuf, pos, n) != n) return 0;
d157 2
a158 2
u_int putle8 (fd, buffer, pos, num)
     int fd;
d176 1
a176 1
  if (put (fd, (char *)iobuf, pos, n) != n) return 0;
d180 2
a181 2
u_int gethe8 (fd, buffer, pos, num)
     int fd;
d192 1
a192 1
  if (get (fd, (char *)iobuf, pos, n) != n) return 0;
d205 2
a206 2
u_int puthe8 (fd, buffer, pos, num)
     int fd;
d224 1
a224 1
  if (put (fd, (char *)iobuf, pos, n) != n) return 0;
d228 2
a229 2
u_int getle4 (fd, buffer, pos, num)
     int fd;
d240 1
a240 1
  if (get (fd, (char *)iobuf, pos, n) != n) return 0;
d250 2
a251 2
u_int putle4 (fd, buffer, pos, num)
     int fd;
d267 1
a267 1
  if (put (fd, (char *)iobuf, pos, n) != n) return 0;
d271 2
a272 2
u_int gethe4 (fd, buffer, pos, num)
     int fd;
d283 1
a283 1
  if (get (fd, (char *)iobuf, pos, n) != n) return 0;
d293 2
a294 2
u_int puthe4 (fd, buffer, pos, num)
     int fd;
d310 1
a310 1
  if (put (fd, (char *)iobuf, pos, n) != n) return 0;
d314 2
a315 2
u_int getle2 (fd, buffer, pos, num)
     int fd;
d322 1
a322 1
  if (get (fd, (char *)iobuf, pos, n) != n) return 0;
d330 2
a331 2
u_int putle2 (fd, buffer, pos, num)
     int fd;
d343 1
a343 1
  if (put (fd, (char *)iobuf, pos, n) != n) return 0;
d347 2
a348 2
u_int gethe2 (fd, buffer, pos, num)
     int fd;
d355 1
a355 1
  if (get (fd, (char *)iobuf, pos, n) != n) return 0;
d363 2
a364 2
u_int puthe2 (fd, buffer, pos, num)
     int fd;
d376 1
a376 1
  if (put (fd, (char *)iobuf, pos, n) != n) return 0;
d380 2
a381 2
u_int getle2s (fd, buffer, pos, num)
     int fd;
d388 1
a388 1
  if (get (fd, (char *)iobuf, pos, n) != n) return 0;
d396 2
a397 2
u_int gethe2s (fd, buffer, pos, num)
     int fd;
d404 1
a404 1
  if (get (fd, (char *)iobuf, pos, n) != n) return 0;
@


1.7
log
@reestablished traditional function declarations for compatibility with
non ANSI compilers
@
text
@d1 8
d14 1
a14 1
static char rcsid[] = "$Id: getputint.c,v 1.5 1992/05/13 23:28:17 se Exp $";
d16 5
a20 1
/* $Log:	getputint.c,v $
@


1.6
log
@changed 2nd parameter to get and put from char* to void* and introduced
local char *buffer for actual accesses
@
text
@d8 5
a12 1
/* $Log: getputint.c,v $
d29 5
a33 1
int get (int fd, void *buf, u_int pos, u_int num)
d37 1
a37 1
  char *buffer = buf;
d72 5
a76 1
int put (int fd, void *buf, u_int pos, u_int num)
d80 1
a80 1
  char *buffer = buf;
@


1.5
log
@changed type of parameter 'buffer' to get and put back to char *
because of compiler complaints about unknown size of *buffer
@
text
@d6 1
a6 1
static char rcsid[] = "$Id: getputint.c,v 1.4 1992/03/31 01:55:01 se Exp $";
d9 4
d25 1
a25 1
int get (int fd, char *buffer, u_int pos, u_int num)
d29 1
d64 1
a64 1
int put (int fd, char *buffer, u_int pos, u_int num)
d68 1
@


1.4
log
@changed type of buffer from char* to void*
@
text
@d6 1
a6 1
static char rcsid[] = "$Id: getputint.c,v 1.3 1992/02/15 17:22:42 se Exp $";
d9 3
d21 1
a21 1
int get (int fd, void *buffer, u_int pos, u_int num)
d59 1
a59 1
int put (int fd, void *buffer, u_int pos, u_int num)
@


1.3
log
@new functions for high and low endian 8 byte values {get,put}_{l,h}e8()
@
text
@d6 1
a6 1
static char rcsid[] = "$Id: getputint.c,v 1.2 1992/02/13 14:37:45 se Exp $";
d9 3
d18 1
a18 1
int get (int fd, char *buffer, u_int pos, u_int num)
d56 1
a56 1
int put (int fd, char *buffer, u_int pos, u_int num)
@


1.2
log
@added rcsid[]
@
text
@d6 1
a6 1
static char rcsid[] = "$Id$";
d8 4
a11 1
/* $Log$
d90 96
@


1.1
log
@Initial revision
@
text
@d6 5
@
